[{"title":"线程与进程","url":"/dp.github.io/2020/03/17/xjc/","content":"\n#### python 提高：\n\n##### 线程与进程的区别：\n\n> 1. 进程是系统进行资源分配和调度的一个单位，线程是进程的一个实体，是cpu调度和分配的基本单位。\n> 2. 进程之间是相互独立的，多进程中，同一个变量，各自有一个备份存在于每个进程中，但互不影响；而同一个进程的多个线程是内存共享的，所有变量都由所有线程共享。\n> 3. 由于进程间是相互独立的，因此一个进程的崩溃不会影响到其他进程；而线程是包含在进程之内的， 线程的崩溃就会引发进程的崩溃，继而导致同一个进程内的其他线程也崩溃。多线程非全局变量是否要加锁；在多线程开发中，全局变量是多个线程都共享的数据，为了防止数据混乱，通常使用互斥锁。而局部变量等是各自线程的，是非共享的，所以不需要使用互斥锁。\n\n\n\n##### GIL（全局解释器锁）\n\n**描述Python GIL的概念， 以及它对python多线程的影响？** \n\n**参考：**\n\n> 1. Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。\n> 2. GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。\n> 3. 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100\n> 4. Python使用多进程是可以利用多核的CPU资源的。\n> 5. 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁。\n\n\n\n##### 深拷贝、浅拷贝：\n\n1. **浅拷贝**\n   1. 浅拷贝是对于一个对象的顶层拷贝，拷贝了引用，并没有拷贝内容。\n\n![img](file:///D:/BaiduNetdiskDownload/24%E6%9C%9Fpython%E5%B0%B1%E4%B8%9A%E7%8F%AD%E8%AF%BE%E4%BB%B6/05-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1-%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%96%99/python%E9%AB%98%E7%BA%A7-%E5%90%8E12%E5%A4%A9%E8%AF%BE%E4%BB%B6(html%E7%89%88)/Images/new_12day/QQ20171023-204000@2x.png) \n\n![img](file:///D:/BaiduNetdiskDownload/24%E6%9C%9Fpython%E5%B0%B1%E4%B8%9A%E7%8F%AD%E8%AF%BE%E4%BB%B6/05-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1-%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%96%99/python%E9%AB%98%E7%BA%A7-%E5%90%8E12%E5%A4%A9%E8%AF%BE%E4%BB%B6(html%E7%89%88)/Images/new_12day/QQ20170420-071018@2x.png) \n\n2. **深拷贝**\n   1. 深拷贝是对于一个对象所有层次的拷贝(递归) \n\n![img](file:///D:/BaiduNetdiskDownload/24%E6%9C%9Fpython%E5%B0%B1%E4%B8%9A%E7%8F%AD%E8%AF%BE%E4%BB%B6/05-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1-%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%96%99/python%E9%AB%98%E7%BA%A7-%E5%90%8E12%E5%A4%A9%E8%AF%BE%E4%BB%B6(html%E7%89%88)/Images/new_12day/QQ20171023-204653@2x.png) \n\n**进一步理解深拷贝**\n\n![img](file:///D:/BaiduNetdiskDownload/24%E6%9C%9Fpython%E5%B0%B1%E4%B8%9A%E7%8F%AD%E8%AF%BE%E4%BB%B6/05-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1-%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%96%99/python%E9%AB%98%E7%BA%A7-%E5%90%8E12%E5%A4%A9%E8%AF%BE%E4%BB%B6(html%E7%89%88)/Images/new_12day/QQ20171023-205139@2x.png) \n\n![img](file:///D:/BaiduNetdiskDownload/24%E6%9C%9Fpython%E5%B0%B1%E4%B8%9A%E7%8F%AD%E8%AF%BE%E4%BB%B6/05-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1-%E4%B8%8A%E8%AF%BE%E8%B5%84%E6%96%99/python%E9%AB%98%E7%BA%A7-%E5%90%8E12%E5%A4%A9%E8%AF%BE%E4%BB%B6(html%E7%89%88)/Images/new_12day/QQ20171023-205202@2x.png) \n\n3. **注意点**\n\n   **浅拷贝对不可变类型和可变类型的copy不同**\n\n   1. copy.copy对于可变类型，会进行浅拷贝 。\n   2. copy.copy对于不可变类型，不会拷贝，仅仅是指向 。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["python"],"categories":["python"]},{"title":"网络爬虫分类详解","url":"/dp.github.io/2020/03/17/pac1/","content":"\n##### 爬虫分类\n\n1.通用网络爬虫；\n        通用网络爬虫又叫做全网爬虫，通用网络爬虫的爬取范围和数量巨大，正由于其爬取的数据是海量数据，\n        所以对于爬取速度和存储空间要求较高。通用网络在爬行页面的顺序要求上相对较低，同时由于待刷新的\n        页面太多，通常采用并行工作方式，所以需要较长时间才可以刷新一次页面，所以存在一定的缺陷，这种\n        网络爬虫主要应用于大型搜索引擎中，又非常高应用价值。通用网络爬虫主要由初始URL集合、URL队列、\n        页面爬取模块、页面分析模块、页面数据库、链接过滤模块等构成。\n\n2.聚焦网络爬虫；\n        聚焦网络爬虫也叫做主题网络爬虫，是指按照预定好的主题，有选择地进行相关网页爬取。他和通用\n        网络爬虫相比，不会将目标资源定位在整个互联网当中，而是将爬取目标网页定位在相关的页面中。这\n        样极大地节省了硬件和网络资源，保存的页面也由于数量少而更快了，聚焦网络爬虫主要应用在对特定\n        信息爬取，为某一特定人群提供服务。\n3.增量式网络爬虫；\n        增量式网络爬虫，所谓增量式，对应着增量式更新。增量式更新指的是在更新的时候只更新改变的地方，\n        而未改变的地方则不更新，所以增量式网络爬虫，在爬取网页的时候，只会在需要的时候爬区新产生或跟\n        新的页面，对于没有更新的页面，则不会爬取。这样可有效减少数据下载量，减少时间和空间上的消费，\n        但是再爬行算法上需要增加一些难度。\n4.深层网络爬虫；\n        web页面按存在方式可以分为表层网页和深层网页，表层网页指的是不需要提交表单，使用静态的超链\t接，\n        就可以直接访问静态页面。深层网页指的是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后面\n        的，需要用户提交一些关键词才能获得的web页面。深层页面需要访问的信息数量是表层页面信息数量的几\n        百倍，所以深层页面是主要的爬取对象。\n\n##### 网络爬虫的基本原理：\n\n- [ ] 网络爬虫的基本工作流程；\n\n​    （1）获取初始的URL，该URL地址使用户自己制定的初始爬取的网页。\n    （2）爬取对应的URL地址的网页时，获取新的URL地址。\n    （3）将新的URL地址放入URL队列中。\n    （4）从URL对列中读取新的URL，然后根据新的URL爬取网页，同时从新的网页中获取新的URL地址，重复上\t\t\t 述爬虫过程。\n    （5）设置停止条件，如果没有设置停止条件爬虫会一直爬取直到无法获取新的URL。\n\n##### python网络请求：\n\n在python中实现HTTP网络请求常见三种方式：urllib、urlliib3、requests。\n\n###### **urllib 模块**\n\n​        urllib是python自带模块，该模块提供了一个urlopen()方法，通过该方法指定URL发送网络请求来获取数据。\n        urllib提供了多个子模块具体如下：\n\n​        模块名称            |                 描述\n        urllib.request   |   该模块定义了打开URL（主要是HTTP）的方法和类。例如身份验证、重定向、cookie等。\n        urllib.error        |   该模块主要包含异常类，基本的异常类是URLError。\n        urllib.parse       |   该模块定义的功能分为两大类：URL解析和URL引用。\n        urllib.robotparser | 该模块用于解析robots.txt 文件。\n\n网络请求示例:\n\n\n```python\n# 示例一\nimport urllib.request\n# 打开指定需要爬取的网页\nresponse = urllib.request.urlopen('http://httpbin.org/get')\nhtml = response.read()  # 读取网页代码\nprint(html)             # 打印读取内容\n```\n\n```python\n# 示例二\nimport urllib.request\nimport urllib.parse\n# 将数据使用urlencode编码处理后，在使用encoding设置为utf-8编码\ndata = bytes(urllib.parse.urlencode({'word':'hello'}),encoding='utf-8')\n# 打开指定需要爬取的网页\nresponse = urllib.request.urlopen('http://httpbin.org/post',data=data)\nhtml = response.read()  # 读取网页代码\nprint(html)             # 打印读取内容\n```\n上面示例中，示例一是通过get请求方式获取网页内容，示例二是通过post请求方式获取网页内容。\n\n\n\n###### **urllib3 模块**\n\nurllib3是一个功能强大、条理清晰、用于HTTP客户端的python库，许多python的原生系统已经开始使用urllib3。\n**urllib3 提供了很多python标准库里所没有的重要特性：**\n （1）线程安全。\n （2）连接池。\n （3）客户端SSL/TTS验证。\n （4）使用多部分编码上传文件。\n （5）Helpers 用于重试请求并处理HTTP重定向。\n （6）支持gzip和deflate编码。\n （7） 支持HTTP和SOCKS代理。\n （8）100% 的测试覆盖率。\n\n网络请求示例:\n\n\n```python\nimport urllib3\n\n# 创建 poolManager对象，用于处理于线程池的连接以及线程安全的所有细节。\nhttp = urllib3.poolManager()\n# 对需要爬取的网页发送请求  get/post\nresponse = http.request('GET','http://httpbin.org/')\n# response = http.request('POST','http://httpbin.org/',fields={'word':'hello'})\nprint(response.data)    # 打印读取内容\n```\n\n###### **requests 模块**\n\nrequests 是第三方模块，该模块在实现HTTP请求时要比urllib 模块简单化很多，操作人性化。\n\n​    **requests 功能特性如下:**\n\n​    (1)Keep-Alive & 连接池            (2)Unicode 响应体\n\n​    (3)国际化域名和URL                 (4)HTTP(S)代理支持\n\n​    (5)带持久Cookie 的会话           (6)文件分块上传\n\n​    (7)浏览器式的SSL认证              (8)流下载\n\n​    (9)自动内容解码                        (10)连接超时\n\n​    (11)基本/摘要式的身份验证            (12)分块请求\n\n   (13)key/value Cookie              (14)支持.netrc\n\n   (15)自动解压\n\n以GET请求为例，打印多种请求信息:\n\n ```python \nimport requests\n\nresponse = requests.get('https://www.baidu.com')\nprint(response.status_code)   # 打印状态码\nprint(response.url)   # 打印请求url\nprint(response.headers)   # 打印头部信息\nprint(response.cookies)   # 打印cookie信息\nprint(respomse.text)   # 以文本形式打印网页源码\nprint(response.content)   # 以字节流形式打印网页源码\n\n以post请求，发送http网络请求:\nimport requests\ndata = {'word':'hello'}\nresponse = requests.post('https://www.baidu.com',data=data)\nprint(response.content)\n ```\n\n**requests 模块不及提供了以上两种，还有多种方式:**\n\n​    (1) requests.put()     \n\n​    (2) requests.delete()  \n\n​    (3) requests.head()  \n\n​    (4) requests.options()\n\n**requests 模块提供了三种常见的网络异常类，示例如下:**\n\n\n```python\n# 导入 requests.exceptions 模块中三个异常类\nfrom requests.exceptions import ReadTimeout, HTTPError, RequestException\nReadTimeout（超时异常） HTTPError（HTTP异常） RequestException（请求异常）\n```\n","tags":["爬虫"],"categories":["python"]},{"title":"使用 python 解析 ppt 文档","url":"/dp.github.io/2020/03/15/jppt/","content":"**模块的重载**：考虑到性能的原因，每个模块只被导入一次,放入字典**sys.module**中，如果你改变了模块的内容，你必须重启程序，**python**不支持重新加载或卸载之前导入的模块，可以使用importlib 模块(python默认编码是ASCII编码，当程序出现非ASCII码时，**python**处理常常出现[UnicodeDecodeError:]错误，此时需要自己设置编码，通常为utf-8)。\n\t\t  \n**具体代码：**\n\n```python\nimport sys,importlib\nimportlib.reload(sys)\nimport time\ntime1=time.time()\nimport os.path\nfrom pdfminer.pdfparser import PDFParser,PDFDocument\nfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter\nfrom pdfminer.converter import PDFPageAggregator\nfrom pdfminer.layout import LTTextBoxHorizontal,LAParams\nfrom pdfminer.pdfinterp import PDFTextExtractionNotAllowed\nresult=[]\nclass CPdf2TxtManager():\n    def __init__(self):\n      '''''\n      Constructor\n      '''\n    def changePdfToText(self, filePath):\n      file = open(path, 'rb') # 以二进制读模式打开\n      #用文件对象来创建一个pdf文档分析器\n      praser = PDFParser(file)\n      # 创建一个PDF文档\n      doc = PDFDocument()\n      # 连接分析器 与文档对象\n      praser.set_document(doc)\n      doc.set_parser(praser)\n      # 提供初始化密码\n      # 如果没有密码 就创建一个空的字符串\n      doc.initialize()\n      # 检测文档是否提供txt转换，不提供就忽略\n      if not doc.is_extractable:\n        raise PDFTextExtractionNotAllowed\n      # 创建PDf 资源管理器 来管理共享资源\n      rsrcmgr = PDFResourceManager()\n      # 创建一个PDF设备对象\n      laparams = LAParams()\n      device = PDFPageAggregator(rsrcmgr, laparams=laparams)\n      # 创建一个PDF解释器对象\n      interpreter = PDFPageInterpreter(rsrcmgr, device)\n      pdfStr = ''\n      # 循环遍历列表，每次处理一个page的内容\n      for page in doc.get_pages(): # doc.get_pages() 获取page列表\n        interpreter.process_page(page)\n        # 接受该页面的LTPage对象\n        layout = device.get_result()\n        for x in layout:\n          if hasattr(x, \"get_text\"):\n            # print x.get_text()\n            result.append(x.get_text())\n            fileNames = os.path.splitext(filePath)\n            results = x.get_text()\n            # print(results)\nif __name__ == '__main__':\n  '''''\n   解析pdf 文本，保存到txt文件中\n  '''\n  path = u'D:\\text\\book\\text.pdf'\n  pdf2TxtManager = CPdf2TxtManager()\n  pdf2TxtManager.changePdfToText(path)\n  time2 = time.time()\n  print(u'ok,解析pdf结束!')\n  print(u'总共耗时：' + str(time2 - time1) + 's')\n```\n\n\n\n\n\n","tags":["python"],"categories":["python"]},{"title":"扫描并输出局域网占用的 IP 地址","url":"/dp.github.io/2020/03/15/mynew2/","content":"**sys.argv[] 指令:** 是一个程序外部来获取参数的，0是指代码本身的路径。可以通过外部来获取多个参数，类似列表。所以使用[]来获取。\n\n\n**argparse** : \n是命令行解析模块；sys.argv[]是通过外部传的参数，无法通过编辑器直接运行，而是通过dos命令行里操作；两者可以结合使用。\n\n\n\n```python\nimport sys,  socket\nimport threading\n\nlist_of_name = []\nlist_of_ip = []\nthread_pool = []\n\ndef showInfo():\n    print(\"\"\"\n        命令格式：LAN_ip_hostname -all startip\n                LAN_ip_hostname -ip ipaddr\n                LAN_ip_hostname -hostname hostname\n        说明：   -all 扫描局域网中所有IP对应的 hostname，需要起始IP，如192.168.0.1\n                -ip 获取指定ip的hostname\n                -hostname 根据主机名，得到ip地址\n    \"\"\")\n\ndef LanAll(startip):\n    index = startip.rfind('.') # 找出最右边 . 的索引\n    ipfirstpart = startip[0:index + 1] # ip 地址中前三位，如 192.168.0.1\n    intstart = int(startip[index + 1])  # ip 地址最后一位，转为int\n    f = range(intstart,255)\n    global g_mutex\n    g_mutex = threading.Lock()  # 初始化互斥锁\n    for iplastpart in f:\n        targetip = ipfirstpart + str(iplastpart) # 拼接ip\n        # 创建线程对象，存为 thread 线程要执行的函数由 target 指定，args 指定参数，\n        # 可以是元组~。线程号从 1 开始\n        thread = threading.Thread(target=Lanlp2Name,args=(targetip,))\n        thread_pool.append(thread)\n        thread.start()\n    # 阻塞主线程 collect all threads\n    for pos in f:\n        threading.Thread.join(thread_pool[pos - intstart])\n    #输出结果\n    hosts = range(0,len(list_of_name))\n    for host in hosts:\n        print(list_of_ip[host],'======>',list_of_name[host])\n    print('Find',len(list_of_name),'hosts.Done!')\ndef Lanlp2Name(ip):\n    try:\n        (name, aliaslist,addresslist) = socket.gethostbyaddr(ip)\n    except:\n        return\n    global g_mutex # 再次声明\n    g_mutex.acquire()  # 上锁\n    list_of_name.append(name)\n    list_of_ip.append(ip)\n    g_mutex.release()  # 释放锁\ndef LanipToName(ip):\n    try:\n        (name, aliaslist,addresslist) = socket.gethostbyaddr(ip)\n    except:\n        return\n    print('%s ======>%s'%(addresslist,name))\ndef LanName2IP(name):\n    targetip = socket.gethostbyname(name)\n    print(name,'=====>',targetip)\nif __name__ == '__main__':\n    if len(sys.argv) < 3:\n        print('参数错误')\n        showInfo()\n        exit(1)\n    cmds = ['-all','-ip','-hostname']\n    cmd = sys.argv[1] # 命令格式\n    target = sys.argv[2] # ip地址\n    if 0 == cmds.count(cmd):\n        print('参数错误啊')\n        showInfo()\n        exit(1)\n    else:\n        print('开始工作请等待...')\n        if cmd == '-all':\n            LanAll(target) # 输出所有的 主机 与 ip 名\n        elif cmd  == '-ip':\n            LanipToName(target) # 根据当前IP 输出主机名\n        elif cmd == '-hostname':\n            LanName2IP(target)  # 根据当前主机名输出ip\n```\n\n\n\n","tags":["网络"],"categories":["socket"]},{"title":"模拟网络嗅探器","url":"/dp.github.io/2020/02/06/mynew1/","content":"\nstruct: 按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;按照指定格式将字节流转换为Python指定的数据类型;\n\n\n\nICMP协议：ICMP协议用于IP主机、路由器之间传递控制消息，这里的控制消息可以包括很多种:数据报错误信息、网络状况信息、主机状况信息等;虽然这些控制消息虽然并不传输用户数据，但对于用户数据报的有效递交起着重要作用，从TCP//IP的分层结构看ICMP属于网络层,它配合着IP数据报的提交,提高IP数据报递交的可靠性。ICMP是封装在IP数据报中进行发送的，从这点看来 ICMP 协议又有点像一个传输层协议，其实不然，因为ICMP报文的目的不是目的主机上的某个应用程序，它不为应用程序提供传输服务，ICMP报文的目的是目的主机上的网络层处理软件。简单的来说,ICMP协议就像奔波于网络中的一名医生,它能及时检测并汇报网络中可能存在的问题，为解决网络错误或拥塞提供了最有效的手段。\n\n\n\n```python\nimport socket\nimport os\nimport struct\nfrom ctypes import *\n\n\nhost = '192.168.249.1'\n\nclass IP(Structure):\n    _fields = [\n        (\"ihl\", c_ubyte, 4),\n        (\"version\", c_ubyte, 4),\n        (\"tos\", c_ubyte),\n        (\"len\", c_ushort),\n        (\"id\", c_ushort),\n        (\"offset\", c_ushort),\n        (\"ttl\", c_ubyte),\n        (\"protocol_num\", c_ubyte),\n        (\"sum\", c_ushort),\n        (\"src\", c_ulong),\n        (\"dst\", c_ulong)\n        ]\n    def __new__(self, socket_buffer=None):\n        return self.from_buffer_copy(socket_buffer)\n\n    def __init__(self,socket_buffer=None):\n        self.protocol_map = {1:'ICMP', 6:'TCP', 17:'UDP'}\n        self.src_address = socket.inet_ntoa(struct.pack(\"<L\",self.src))\n        self.dst_address = socket.inet_ntoa(struct.pack(\"<L\",self.dst))\n\n        try:\n            self.protocol = self.protocol_map[self.protocol_num]\n\n        except:\n            self.protocol = str(self.protocol_num)\n\nif os.name == \"nt\":\n    socket_protocol = socket.IPPROTO_IP\n\nelse:\n    socket_protocol = socket.IPPROTO_ICMP\n\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)\n\nsniffer.bind((host,0))\n\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL,1)\n\nif os.name == 'nt':\n    sniffer.ioctl(socket.SIO_RCVALL,socket.RCVALL_ON)\n\ntry:\n    while True:\n        raw_buffer = sniffer.recvfrom(65565)[0]\n        ip_header = IP(raw_buffer[0:20])\n        print(\"Protocol:%s %s -> %s\"%(ip_header.protocol,ip_header.src_address,ip_header.dst_address))\nexcept:\n    if os.name == \"nt\":\n        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\n    print('出现错误！')\n```\n\n\n\n\n\n\n\n","tags":["网络"],"categories":["socket"]},{"title":"常用的 GUI 框架","url":"/dp.github.io/2019/12/18/my-first-one/","content":"##### 什么是 GUI\n\n  GUI是 Graphilcal User Interface（图形用户界面）的缩写。在GUI中，并不只是输入文本和返回文本，用户可以看待窗口、按钮、\n  文本框等图形，而且可以用鼠标单击，还可以通过键盘输入。GUI 是与程序交互的一种不同的方式。GUI 的程序由三个基本要素：输入、处理和输出。\n\n##### 常用的GUI框架\n\n  工具包        |                 描述\n  wxpython  |        wxpython是python语言的一套优秀的GUI图形库，允许python程序员方便创建完整的、功能\t\t\t\t\t\t       \t\t\t\t\t  -                               健全的GUI用户界面。\n  Kivy        |        Kivy是一个开源工具包，可以跨平台使用，主要关注创新型用户界面开发，如多点触摸应用程序。\n  Flexx      |        Flexx是纯python工具包，用来创建图形化界面应用程序。使用web技术进行页面渲染。\n  PyQt       |        PyQt是Qt库的python版本，支持跨平台。\n  Tkinter           Tkinter（也叫做Tk接口）是标准的python接口，Tk是一个轻量级的跨平台图形用户界面开发工具。\n  pywin32 |        Windows pywin32允许用户像VC一样的形式来使用python开发win32 应用。\n  PyGTK   |        PyGTK让用户用python轻松创建具有图形用户界面的程序。\n  pyui4win  |        pyui4win是一个开源的采用自绘技术的界面库。\n\n\n\n","tags":["GUI"],"categories":["GUI(图形用户界面)"]}]