[{"title":"Linux shell脚本任务","url":"/dp.github.io/2020/05/14/crontab/","content":"\n##### crontab 任务计划\n\n**cron是一个可以用来根据时间、日期、月份和星期的组合来调度对周期性任务执行的守护进程，利用cron所提供的功能，可以将需要周期性重复执行的任务设置为cron任务，并且设置为在主机较空闲的时间自动完成。**\n\n```shell\n查看Crontab服务:\nsystemctl status crond \n\n任务计划格式:\n*(分) *(时) *(日) *(月) *(周) 周期执行的程序\n\n30 22 2 1 * time.sh\n每年1月2日晚上22:30执行time.sh脚本\n\n30 22 * * 6 time.sh\n每周六晚上22:30执行time.sh脚本\n\n30 22 * * 1,3,5 time.sh\n每周的周一、周三和周五晚上22:30执行time.sh脚本 \n\n30 22 * * 1-5 time.sh\n每周的周一到周五晚上22:30执行time.sh脚本 \n\n* * * * * time.sh\n每分钟执行一次time.sh脚本 \n\n*/5 * * * * time.sh\n每五分钟执行一次time.sh脚本 \n\n00 00 * * * time.sh\n每天晚上00点执行time.sh脚本 \n\n查看cron任务计划:\ncrontab -l\n\n编辑cron任务计划:\ncrontab -e\n\n删除所有cron任务计划:\ncrontab -r\n\n```\n\n\n\n##### cockpit 系统监控\n\n```shell\nCockpit Web系统监控:\nsystemctl enable --now cockpit.socket\n\n开启cockpit服务:\nsystemctl start cockpit.service\n\n查看cockpit状态:\nsystemctl status cockpit.service\n\nWeb系统访问:\nhttps://192.168.2.1:9090\n```\n\n","tags":["Linux"]},{"title":"SSH远程密钥操作与nmcli网络配置信息","url":"/dp.github.io/2020/04/24/linux-ssh/","content":"\n##### 远程密钥登陆\n\n```shell\n1. Windows 生成密钥对。\n   ssh-keygen -t rsa\n\n1. 进入 .ssh 目录\n   cd C:Users/.ssh\n\n2. 将公钥拷贝Linux /root/.ssh 下\n   spc id_rsa.pub root@192.168.2.103:/root/.ssh\n\n3. 在Linux上吧公钥改名\n   mv id_rsa.pub authorized_keys\n\n4. 客户端无口令操作-命令操作\n   ssh root@192.168.2.103\n\n5. 客户端无口令操作-文件传输\n   scp index.py root@192.168.2.103:/root/\n```\n\n\n\n##### nmcli 配置网络信息\n\n**查看nmcli服务命令**\n\n`systemctl status NetworkManager`\n\n**nmcli网络配置基础命令**\n\n```shell\n查看所有网卡的信息\nnmcli \n\n\n查看网络设备状态\nnmcli device status\n\n\n查看网络详细信息(ip+dns+gateway)\nnmcli device show ens32\n\n\n设置静态ip地址\nnmcli connection modify ens32 ipv4.addresses '192.168.1.100'\n\n\n设置DNS\nnmcli connection modify ens32 ipv4.dns '114.114.114.114'\n\n\n设置网关\nnmcli connection modify ens32 ipv4.gateway '192.168.1.1'\n\n\n设置IP地址为手动指定\nnmcli connection modify ens32 ipv4.method manual\n\n\n设置IP地址为dhcp自动获取\nnmcli connection modify ens32 ipv4.method auto\n\n\n设置开机自动连接\nnmcli connection modify ens32 connection.autoconnect yes\nnmcli connection modify ens32 connection.autoconnect no\n\n\nnmcli重新加载ifcfg-ens32配置文件\nnmcli connection reload\n\n\n\n不重启系统让网卡生效的方法:\nnmcli connection up ens32\nnmcli device connect ens32\nnmcli device reapply ens32\n\n\n查看dns:\ncat /etc/resolv.conf\n#nameserver\n\n\n通讯测试:\n检测是否能正常通讯\nping www.baidu.com\n#可测试ip、dns和网关是否都设置正确\n```\n\n\n\n##### Linux （虚拟机VMware）系统启动流程\n\n*系统启动流程*\n\n1. BIOS加电自检\n2. 把MBR加载到内存\n3. 加载grub\n4. Kernel自身初始化\n5. 启动第一个程序systemd\n6. 检查默认运行级别\n7. 启动相应级别下的所有程序服务 \n8. 加载/etc/rc.d/rc.local脚本\n9. systemd执行multi-user.target下的getty.target及登录服务\n10. systemd执行graphical需要的服务\n\n\n\n*Linux运行级别*\n\n| 0                     | 1                              | 2                       | 3                                           | 4    | 5                          | 6        |\n| --------------------- | ------------------------------ | ----------------------- | ------------------------------------------- | ---- | -------------------------- | -------- |\n| shutdown.target(关机) | emergency.target(紧急救援模式) | rescue.target(救援模式) | multi-user.target(多用户模式\\|字符系统模式) | 无   | graphical.target(桌面系统) | 无(重启) |\n\n\n\n*查看默认级别与切换运行级别*\n\n```shell\n查看默认运行级别\nsystemctl get-default\n\n切换运行级别：init命令\ninit 0|1|2|3|5|6\n\n查看运行级别\nrunlevel\n\n查看端口\nnetstat -tunpl |grep sshd\t#查看sshd端口\n```\n\n","tags":["linux"]},{"title":"常用的 GUI 框架","url":"/dp.github.io/2019/12/18/my-first-one/","content":"##### 什么是 GUI\n\n>  GUI是 Graphilcal User Interface（图形用户界面）的缩写。在GUI中，并不只是输入文本和返回文本，用户可以看待窗口、按钮、文本框等图形，而且可以用鼠标单击，还可以通过键盘输入。GUI 是与程序交互的一种不同的方式。GUI 的程序由三个基本要素：输入、处理和输出。\n>\n\n##### 常用的GUI框架\n\n| 工具包   | 描述                                                         |\n| :------- | ------------------------------------------------------------ |\n| wxpython | wxpython是python语言的一套优秀的GUI图形库，允许python程序员方便创建完整的、功能\t\t\t\t       \t\t\t\t\t健全的GUI用户界面。 |\n| Kivy     | Kivy是一个开源工具包，可以跨平台使用，主要关注创新型用户界面开发，如多点触摸应用程序。 |\n| Flexx    | Flexx是纯python工具包，用来创建图形化界面应用程序。使用web技术进行页面渲染。 |\n| PyQt     | PyQt是Qt库的python版本，支持跨平台。                         |\n| Tkinter  | Tkinter（也叫做Tk接口）是标准的python接口，Tk是一个轻量级的跨平台图形用户界面开发工具。 |\n| pywin32  | Windows pywin32允许用户像VC一样的形式来使用python开发win32 应用。 |\n| PyGTK    | PyGTK让用户用python轻松创建具有图形用户界面的程序。          |\n| pyui4win | pyui4win是一个开源的采用自绘技术的界面库。                   |\n\n\n","tags":["GUI"],"categories":["GUI(图形用户界面)"]},{"title":"centOS8管理","url":"/dp.github.io/2019/08/13/linux-management/","content":"\n##### 光盘管理\n\n\n\n|              | 命令                                                         |\n| ------------ | ------------------------------------------------------------ |\n| 挂载光盘     | mount /dev/cdrom /media                                      |\n| 查看挂载情况 | df   /    df -h     / df -Th                                 |\n| 卸载光盘     | umount /media                                                |\n| 开机挂载     | 首先进入：vi /etc/fstab ;   添加 :  /dev/cdrom        /media         iso9660 defaults   0   0 |\n| 开机挂在测试 | mount -a                                                     |\n\n##### RPM包管理\n\n| RPM是什么：redhat package management英文缩写，只适于于Redhat和Centos系统 |\n| ------------------------------------------------------------ |\n| 安装RPM包：  rpm -ivh installing software                    |\n| 查看RPM包：  rpm -qa software                                |\n| 查看RPM包安装的文件:     rpm -ql software                    |\n| 反查文件是否由RPM 安装：  rpm -qf path                       |\n| 删除RPM安装的程序：  rpm -e software                         |\n\n##### YUM软件包管理\n\n```shell\n1.检查光盘是否正常挂载\ndf\n\n2.挂载\nmount /dev/cdrom /media\n\n配置YUM仓库:\n1.删除其他repo文件，只留下CentOS-Media.repo\ncd /etc/yum.repos.d/\nmv CentOS-Media.repo /mnt\nrm -rf *\nmv /mnt/CentOS-Media.repo ./\n\n2.设置CentOS-Media.repo文件\nvi CentOS-Media.repo\n[c8-media-BaseOS]\nbaseurl=file:///media/BaseOS\ngpgcheck=0\nenabled=1\n\n[c8-media-AppStream]\nbaseurl=file:///media/AppStream\ngpgcheck=0\nenabled=1\n\n查看YUM可控制的软件包\nyum list\nyum list | wc -l\nyum list | grep httpd\n\nYUM安装rpm软件包\nyum -y install httpd\n\n用YUM如何去卸载rpm包\nyum -y remove httpd \n\n```\n\n","tags":["linux"]},{"title":"Linux vi编辑与压缩","url":"/dp.github.io/2019/07/13/vi-ys/","content":"\n##### vi编辑器的概述\n\n1. Vi是Unix及Linux系统下标准的编辑器，由美国加州大学伯克利分校开发。学会它后，您将在Linux的世界里畅行无阻。基本上vi可以分为三种状态，分别是命令模式、插入模式，和底行模式。\n\n\n\n##### vi编辑器的模式\n\n1. 命令模式 command\n2. 输入模式 insert\n3. 末行模式 :末行命令\n4. 视图模式 visual\n\n###### vi编辑器-输入模式\n\n| 字符 | 描述                     |\n| ---- | ------------------------ |\n| a    | 在当前字符的后面输入     |\n| s    | 删除当前字符并输入       |\n| i    | 在当前字符的前面输入     |\n| o    | 当前字符所在行下方输入   |\n| A    | 当前行后面输入           |\n| S    | 删除当前行并输入         |\n| I    | 当前行前面输入           |\n| O    | 当前字符所在行上一行输入 |\n\n###### vi编辑器-命令模式\n\n| 字符                 | 描述                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| H                    | 控制方向---左                                                |\n| J                    | 控制方向---下                                                |\n| K                    | 控制方向---上                                                |\n| L                    | 控制方向---右                                                |\n| x                    | 删除当前字符,3x删除三个字符                                  |\n| d^  /  .d$           | 当前字符删除到^行首&行尾                                     |\n| dd / dw              | 删除一行  /  删除一个单词                                    |\n| G  / nG  /dG  /  d1G | 最后一行  / 第 n 行  / 从当前行删除到最后一行  /  从当前行删除到第一行 |\n| yy  / nyy            | 复制当前行  /  复制n行                                       |\n\n| 字符               | 描述                                                       |\n| ------------------ | ---------------------------------------------------------- |\n| p  /  np  /  P     | 粘贴到下一行  /  重复粘贴np次  / 粘贴上一行                |\n| u                  | 撤销                                                       |\n| ctrl+r             | 恢复                                                       |\n| /word              | 查找word单词，查找多个n键                                  |\n| q  /  q!           | 不保存退出  /  强制不保存退出                              |\n| x  / wq            | 保存退出,与 wq一致                                         |\n| w                  | 保存不退出                                                 |\n| %s/hello/word/g    | 把一篇文章中的所有hello全部替换成world,%第一行到最后的意思 |\n| 1,10s/hello/word/g | 把第1行到第10行的hello替换成world                          |\n\n#####  Gz、Bz2和Zip压缩包操作\n\n**Gz压缩包管理**\n\n> 1. 制作gz压缩包:        |           tar czf mydir1.tar.gz mydir1\n> 2. gz压缩包解压:        |           tar xzf mydir1.tar.gz\n> 3. 查看gz压缩包:        |           tar tf mydir1.tar.gz\n\n**Bz2压缩包管理**\n\n> 1. 制作bz2压缩包:      |           tar cjf mydir1.tar.bz2 mydir1\n>\n> 2. bz2压缩包解压:      |           tar xjf mydir1.tar.bz2\n>\n> 3. 查看bz2压缩包:      |           tar tf mydir1.tar.bz2\n\n**Zip压缩包管理**\n\n> 1. 制作zip压缩包:        |            zip -r mydir1.zip mydir1\n>\n> 2. zip压缩包解压:        |            unzip mydir1.zip\n>\n> 3. 查看zip压缩包:        |            unzip -l mydir1.zip\n\n","tags":["linux"]},{"title":"vue","url":"/dp.github.io/2019/06/21/get-vue/","content":"\n### vue.js简介：\n\n1. vue是基于MVVM模式实现的\n\n   M：model表示模型，机器可读性强的数据\n\n   V：view表示视图，人眼可读性强的数据\n\n   VM：viewmodel表示视图模型，将机器可读性强的数据转化成人眼可读性强的数据转化为机器可读性强的数据（前端的本质）\n\n2. 数据由视图流入模型通过事件监听实现，数据由模型流入视图通过数据的绑定实现的，这就是数据的双向绑定（MVVM模式的标识）\n\n3. vue.js与jQuery\n\n   1. 在过去，前端的任务就是为页面绑定一些交互，处理一些数据，浏览器兼容性问题是最重要的问题，所以jQuery的出现就是为了解决这类问题\n   2. 随着前端的发展，前端的业务越来越多，如何能够保证代码的安全，可靠，兼容，可延展性，可维护是现在的主要问题\n   3. jQuery没有将前端业务逻辑抽象分离，所有代码写在一起，很难维护，很难扩展，所以一些框架呼之欲出\n   4. 将业务分成模型，视图，控制器，提高代码的可维护性等，但是开发很慢，所以MVVM模式的框架就出现了，vue就是其中的代表之一\n\n\n\n### 常用指令\n\n- v-if判断\n- v-for循环\n- v-model数据双向绑定\n- v-bind样式属性绑定\n\n\n\n### 组件的生命周期（8个钩子函数）\n\n1. vue将组件看成是一个有生命的个体，跟人一样，定义了各个阶段\n\n2. 组件的生命周期：组件的创建过程\n\n3. 组件生命周期钩子函数：当组件处在某个阶段，要执行某个方法，来通知我们，组件进入某个阶段，这个方法就是组件生命周期的钩子函数\n\n4. 组件的创建过程：这些方法在组件中直接定义，会按照顺序执行，没有参数，作用域都是组件实例化对象\n\n   创建：创建前、创建后\n\n   挂载：挂载前、挂载后\n\n   更新：更新前、更新后\n\n   销毁：销毁前、销毁后\n\n\n\n最常用的两个：\n\n1. created：实例已经创建完成，并且已经进行数据观测和事件配置\n2. mouted：模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示\n\n\n\n\n\n### 路由\n\n路由传参：\n\n​\t\t/page/:pageNum\n\n​\t\t匹配：/page/10,/page/100,/page/hello\n\n获取传参：\n\n1. 通过params属性，即可获取动态路由参数  $route.params.id（在控制台可以这样获取：app.$route）\n2. 通过query属性，获取query参数  $route.query.word （在控制台可以这样获取：app.$route.query）\n\n\n\n嵌套路由\n\n1. 路由可以嵌套定义。也就是说路由中可以定义其子路由\n\n2. 分成2步：\n\n   第一步：在路由的模板中，定义router-view元素，定义渲染的容器\n\n   第二部：在路由对象中添加children属性，属性值是数据\n\n3. 嵌套路由举例\n\n   1. 如果路径后加上  #/home仅显示home页面组件\n   2. 如果路径加上 #/home/search会同时显示home组件和子组件search组件中内容\n   3. 由于page子路由中写的是绝对路径'/page'所以访问路径变成#/page而不用加上父路径home，显示home组件和page组件\n\n\n\n### 组件间通信\n\n1. 组件间的通信说明\n\n   1. 组件间通信就是指组件之间是如何传递数据的\n\n      父组件：vue实例化对象\n\n      子组件：自定义组件\n\n   2. 组件的template属性，除了可以是字符串，还可以是元素的id\n\n   3. 我们在页面中定义模板的时候，除了可以定义在script模板标签中，还可以定义在template模板中\n\n      父组件子组件：如果你在一个组件A里面，用到了另外一个组件B，那么B就是A的子组件，A就是B的父组件\n\n2. 父组件向子组件通信：分为以下两步\n\n   1. 第一步：\n\n      1. 在组件容器元素上，定义自定义属性，属性值可以传递父组件中的数据\n\n      2. 如果属性使用了v-bind指令，属性值就是js环境\n\n      3. 如果属性没有使用v-bind指令，属性值就是字符串\n\n         ```\n         <ickt demo=\"hello\" v-bind:parent-msg=\"msg\"></ickt>\n         ```\n\n          #hello 是字符串， msg是变量\n\n   2. 第二步\n\n      1. 在组建中定义props属性，属性值是数组，没一个成员代表组件容器元素上的一个属性\n      2. 作用：将属性作为变量，注册在子组件中，可以在子组件中使用（包括模板）\n      3. 注意：如果属性名称，出现了-，注册的变量要使用驼峰式命名法\n\n   3. 例子说明\n\n      1. 在当页面中注册了子组件，Ickt，在子组件中是无法使用父组件中定义的数据msg的\n\n      2. 如果想要在子组件Ickt中使用父组件的msg变量，可以使用\n\n         ```\n         <ickt v-bind:parent-msg=\"msg\"></ickt>\n         ```\n\n      3. 在子组件中使用{{parent-msg}}就可以访问父组件的msg变量了\n\n   \n\n   1. ### 1.0中子组件向父组件通信分以下两步\n\n      1. 第一步：注册时间\n\n         在父组件的events属性中注册消息，参数就是触发是传递的数据，作用域是组件实例化对象\n\n      2. 第二步：触发时间\n\n         在子组件中，通过$dispatch方法触发消息\n\n   2. 2.0中改变\n\n      1. 将$dispatch，$broadcast移除了，新增了$emit，$on，$off\n         - $emit发布消息\n         - $on注册消息：参数就是$emit传递的数据，作用域就是组件实例化对象\n         - $off注销信息\n      2. 没一个组件相当于一个事件对象，只能在自身订阅，触发，以及发布\n      3. 注意：工作中，注册事件通常在组件生命周期方法中注册，例如created\n\n\n\n### vue实现数据绑定原理\n\n1. vue使用数据劫持实现数据双向绑定\n   1. vue.js采用数据劫持结合发布者-订阅者模式的方式，通过object.defineProperty()来劫持各个属性的setter，getter\n   2. 在数据变动时发布消息给订阅者，触发相应的监听回调\n2. 数据劫持原理\n   1. 实现一个数据监听器observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者\n   2. 实现一个指令解析器compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\n   3. 实现一个watcher，作为连接observer和compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的响应回调函数，从而更新视图\n   4. MVVM入口函数，整合以上三者\n\n\n\n### 懒加载\n\n懒加载----也称为延迟加载，即在需要的时候才加载（效率低，占用内存小）。所谓懒加载，写的是其get方法\n\n注意：如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化\n\n使用懒加载的好处：\n\n1. 不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强\n2. 每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合\n\n比如，我们应该都见过这样的场景：一个页面有很多图片，但是首屏只出现几张，这时如果一次性把图片都加载出来会影响性能。这时可以使用懒加载，页面滚动到可视区在加载。优化首屏加载\n\n实现：img标签的src属性为空，给一个data-xx属，里面存放图片真实地址，当页面滚动至此图片出现在可视区域时，用js取到该图片的data-xx的值赋给src。\n\n优点：页面加载速度快，减轻服务器压力，节约流量，用户体验好\n\n\n\n1. 什么是vuex?\n\n   1. 官方说法：vuex是一个专为vue.js应用程序开发的状态管理模式\n   2. 它采用集中式存储管理应用的所有组件的状态，并以响应的规则保证状态以一种可预测的方式发生变化\n   3. 个人理解：vuex是用来管理组件之间通信的一个插件\n\n2. vuex作用\n\n   1. 我们知道组件之间是独立的，组件之间想要实现通信，我目前知道的就只有props选项，但这也仅限于父组件和子组件之间的通信\n\n   2. 如果兄弟组件之间想要实现通信呢？当做中大型项目时，面对一大堆组件之间的通信，还有一大堆的逻辑代码，会不会抓狂？\n\n   3. 那为何不把组件之间共享的数据给拎出来，在一定的规则下管理这些数据呢？这就是vuex的基本思想了\n\n      总结：使用vuex作用就是实现组件间数据共享\n\n3. vuex原理\n\n   1. vue团队为了简化组件间的通信，将state抽象成一个单例模式，将其放到全局，让各个组件都能共享使用\n\n   2. vuex数据传递是单向的：action--》mutation--》state--》component--》action\n\n      vue  component指的就是我们定义的组件\n\n      action交互中产生的动作\n\n      mutations动作产生的修改数据的行为\n\n      state共享数据\n\n   3. vuex设计的时候相对修改的行为做单测（测试），开发了devtools来做测试，只能检测同步的操作。\n\n   4. 规范定义：只能在mutations中做同步操作，所以增加了action来异步处理数据\n\n   5. 将mutations中的异步操作转移到actions中了，这样就可以测试同步的操作了。\n\n4. vuex使用场景\n\n   1. 如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，vuex将会成为自然而然的选择。\n   2. 如果您不打算开发大型单页应用，使用vuex可能是繁琐冗余的。\n\n5. vuex流程图\n\n   1. vue组件（Vue Components）会发出（Dispatch）一些动作（Actions）\n   2. 动作会提交（Commit）一个对数据的改变（Mutations）\n   3. 提交的改变数据存放在状态（State）中的\n   4. 最后State将改变的数据再渲染（Render）到组件（Vue Components），展示被改变后的数据\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["vue"]},{"title":"Linux 内核","url":"/dp.github.io/2019/06/01/kernel-linux/","content":"\n##### linux 内核\n\n`Linux内核是操作系统中最核心和关键的部分，具有稳定、高性能、容易维护等优点。`\n\n###### Linux系统内核主要负责这个几个部分：\n\n1. 对进程的管理\n\n   1. Linux 对进程的管理主要就是上下文切换，涉及到进程的启动、暂停、恢复与终止。其实更准确地来说应该是对任务的管理，因为管理不仅仅是进程，还有线程，在Linux上将进程与线程统一称之为任务。\n\n   2. 早期的Linux上对线程支持不好，二者区别并不是很大，随着CPU的升级以及内核的改进，Linux上的线程也比原先性能改进很多。上下文切换其实就是CPU时间片轮换的过程，内核提供了任务调度器，保障每个任务都能获得其应有的CPU时间片，而内核会在上下文切换的时间间隙中获得CPU。\n\n   3. 在多核CPU系统中，如果新的进程在另一个CPU上执行，那么内核就不会让出当前CPU使用权，与此同时，内核会采用一些其它方法来提高CPU的使用率。\n\n2. 对内存的管理\n\n   1. 当前CPU基本都已经实现了一种叫做MMU的机制，该机制提供了虚拟内存的内存访问机制。举个例子，如果所分配的内存表面上看即便时连续的。在物理内存上也有可能不是连续的，因为整个过程都是虚拟的，用户无法直接感知。这相当于在物理内存之上抽象出来一个中间的映射层，通过整个中间层来访问实际的内存空间。这与Java虚拟机的感觉是类似的，只不过MMU要比Java虚拟机这种简单一些，可以理解为一个MAP映射一样的东西，称之为内存映射表。\n\n   2. 通过这里的虚拟内存机制，可以保障内核空间与用户空间隔离，在内核进行上下文切换时，将MMU（内存管理单元）的内存映射表转交给获得CPU使用权的新进程使用，同时也便于内存管理。\n\n3. 提供系统调用\n\n   1. 系统提供应用程序不能直接实现的API，例如打开文件，读取文件内容创建套接字等等，这些都需要在内核中实现。举个例子，如果创建套接字需要进行通信，则内核需要将接收到的数据拷贝到用户空间中，当前进程才可以使用，这个过程需要内核进行维护。于此同时，内核还需要维护设备驱动，这样用户就可以通过访问文件系统的方式来与设备进行IO通信。","tags":["linux"]},{"title":"python 解释器","url":"/dp.github.io/2019/03/27/p-jsq/","content":"\n#### python各个版本解释器\n\n> 当我们编写python代码时，我们得到的是一个包含python代码的以`.py`为扩展名的文本文件。要运行代码，就需要python解释器去执行`.py`文件。\n\n\n\n##### CPython\n\n> 当我们从python官网下载并安装好python版本后，我们就直接获得了一个官方版本的解释器：Cpython。这个解释器是用C语言开发的，所以叫Cpython。在命令行运行`python`就是启动了CPython解释器。\n\n\n\n##### IPython\n\n> IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。\n>\n> CPython用`>>>`作为提示符，而IPython用`In [序号]:`作为提示符。\n\n\n\n##### PyPy\n\n> PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用 [JIT技术]，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。\n>\n> 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解[PyPy和CPython的不同点]。\n\n\n\n##### Jyhon\n\n> Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行 。\n\n\n\n##### IronPython\n\n> IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。 ","tags":["python"],"categories":["python"]},{"title":"json 模块","url":"/dp.github.io/2018/03/28/join/","content":"\n##### json 模块\n\n------\n\n**json**是一种轻量级的数据交换格式，python3.x 可以使用json模块来对**json**数据进行编解码。\n\n------\n\n- **json模块的常用方法**\n  - json.dump()\n    - 将**python**数据对象以 **JSON** 格式数据流的形式写入到文件。\n  - json.load()\n    - 解析包含 **JSON** 数据的文件为python对象。\n  - json.dumps()\n    - 将 **python** 数据对象转换为 **JSON** 格式的字符串。\n  - json.loads()\n    - 将包含**JSON**的字符串、字节以及字节数组解析为**python**对象。","tags":["python"],"categories":["python"]},{"title":"网络爬虫分类详解","url":"/dp.github.io/2018/03/17/pac1/","content":"\n##### 爬虫分类\n\n**1.通用网络爬虫；**\n        通用网络爬虫又叫做全网爬虫，通用网络爬虫的爬取范围和数量巨大，正由于其爬取的数据是海量数据，\n        所以对于爬取速度和存储空间要求较高。通用网络在爬行页面的顺序要求上相对较低，同时由于待刷新的\n        页面太多，通常采用并行工作方式，所以需要较长时间才可以刷新一次页面，所以存在一定的缺陷，这种\n        网络爬虫主要应用于大型搜索引擎中，又非常高应用价值。通用网络爬虫主要由初始URL集合、URL队列、\n        页面爬取模块、页面分析模块、页面数据库、链接过滤模块等构成。\n\n**2.聚焦网络爬虫；**\n        聚焦网络爬虫也叫做主题网络爬虫，是指按照预定好的主题，有选择地进行相关网页爬取。他和通用\n        网络爬虫相比，不会将目标资源定位在整个互联网当中，而是将爬取目标网页定位在相关的页面中。这\n        样极大地节省了硬件和网络资源，保存的页面也由于数量少而更快了，聚焦网络爬虫主要应用在对特定\n        信息爬取，为某一特定人群提供服务。\n**3.增量式网络爬虫；**\n        增量式网络爬虫，所谓增量式，对应着增量式更新。增量式更新指的是在更新的时候只更新改变的地方，\n        而未改变的地方则不更新，所以增量式网络爬虫，在爬取网页的时候，只会在需要的时候爬区新产生或跟\n        新的页面，对于没有更新的页面，则不会爬取。这样可有效减少数据下载量，减少时间和空间上的消费，\n        但是再爬行算法上需要增加一些难度。\n**4.深层网络爬虫；**\n        web页面按存在方式可以分为表层网页和深层网页，表层网页指的是不需要提交表单，使用静态的超链\t接，\n        就可以直接访问静态页面。深层网页指的是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后面\n        的，需要用户提交一些关键词才能获得的web页面。深层页面需要访问的信息数量是表层页面信息数量的几\n        百倍，所以深层页面是主要的爬取对象。\n\n\n\n##### 网络爬虫的基本原理：\n\n> 1. 获取初始的URL，该URL地址使用户自己制定的初始爬取的网页。\n> 2. 爬取对应的URL地址的网页时，获取新的URL地址。\n> 3. 将新的URL地址放入URL队列中。\n> 4. 从URL对列中读取新的URL，然后根据新的URL爬取网页，同时从新的网页中获取新的URL地址，重复上述爬虫过程。\n> 5. 设置停止条件，如果没有设置停止条件爬虫会一直爬取直到无法获取新的URL。\n\n\n\n##### python网络请求：\n\n**在python中实现HTTP网z络请求常见三种方式：urllib、urlliib3、requests。**\n\n###### urllib 模块\n\n`urllib是python自带模块，该模块提供了一个urlopen()方法，通过该方法指定URL发送网络请求来获取数据。`\n\n|                    | urllib提供了多个子模块具体如下                               |\n| ------------------ | ------------------------------------------------------------ |\n| 模块名称           | 描述                                                         |\n| urllib.request     | 该模块定义了打开URL（主要是HTTP）的方法和类。例如身份验证、重定向、cookie等。 |\n| urllib.error       | 该模块主要包含异常类，基本的异常类是URLError。               |\n| urllib.parse       | 该模块定义的功能分为两大类：URL解析和URL引用。               |\n| urllib.robotparser | 该模块用于解析robots.txt 文件。                              |\n\n\n\n*网络请求示例:*\n\n\n```python\n# 示例一\nimport urllib.request\n# 打开指定需要爬取的网页\nresponse = urllib.request.urlopen('http://httpbin.org/get')\nhtml = response.read()  # 读取网页代码\nprint(html)             # 打印读取内容\n```\n\n```python\n# 示例二\nimport urllib.request\nimport urllib.parse\n# 将数据使用urlencode编码处理后，在使用encoding设置为utf-8编码\ndata = bytes(urllib.parse.urlencode({'word':'hello'}),encoding='utf-8')\n# 打开指定需要爬取的网页\nresponse = urllib.request.urlopen('http://httpbin.org/post',data=data)\nhtml = response.read()  # 读取网页代码\nprint(html)             # 打印读取内容\n```\n上面示例中，示例一是通过get请求方式获取网页内容，示例二是通过post请求方式获取网页内容。\n\n\n\n###### urllib3 模块\n\n`urllib3是一个功能强大、条理清晰、用于HTTP客户端的python库，许多python的原生系统已经开始使用urllib3。`\n\n| urllib3 提供了很多python标准库里所没有的重要特性 |\n| ------------------------------------------------ |\n| （1）线程安全。                                  |\n| （2）连接池。                                    |\n| （3）客户端SSL/TTS验证。                         |\n| （4）使用多部分编码上传文件。                    |\n| （5）Helpers 用于重试请求并处理HTTP重定向。      |\n| （6）支持gzip和deflate编码。                     |\n| （7） 支持HTTP和SOCKS代理。                      |\n| （8）100% 的测试覆盖率。                         |\n\n\n\n*网络请求示例:*\n\n\n```python\nimport urllib3\n\n# 创建 poolManager对象，用于处理于线程池的连接以及线程安全的所有细节。\nhttp = urllib3.poolManager()\n# 对需要爬取的网页发送请求  get/post\nresponse = http.request('GET','http://httpbin.org/')\n# response = http.request('POST','http://httpbin.org/',fields={'word':'hello'})\nprint(response.data)    # 打印读取内容\n```\n\n\n\n###### requests 模块\n\n`requests 是第三方模块，该模块在实现HTTP请求时要比urllib 模块简单化很多，操作人性化。`\n\n| requests 功能特性如下     |                    |\n| ------------------------- | ------------------ |\n| (1)Keep-Alive & 连接池    | (2)Unicode 响应体  |\n| (3)国际化域名和URL        | (4)HTTP(S)代理支持 |\n| (5)带持久Cookie 的会话    | (6)文件分块上传    |\n| (7)浏览器式的SSL认证      | (8)流下载          |\n| (9)自动内容解码           | (10)连接超时       |\n| (11)基本/摘要式的身份验证 | (12)分块请求       |\n| (13)key/value Cookie      | (14)支持.netrc     |\n| (15)自动解压              |                    |\n\n\n\n*以GET请求为例，打印多种请求信息:*\n\n ```python \nimport requests\n\nresponse = requests.get('https://www.baidu.com')\nprint(response.status_code)   # 打印状态码\nprint(response.url)   # 打印请求url\nprint(response.headers)   # 打印头部信息\nprint(response.cookies)   # 打印cookie信息\nprint(respomse.text)   # 以文本形式打印网页源码\nprint(response.content)   # 以字节流形式打印网页源码\n\n以post请求，发送http网络请求:\nimport requests\ndata = {'word':'hello'}\nresponse = requests.post('https://www.baidu.com',data=data)\nprint(response.content)\n ```\n\n\n\n| requests 模块不及提供了以上两种，还有多种方式: | requests 模块提供了三种常见的网络异常类，示例如下            |\n| ---------------------------------------------- | ------------------------------------------------------------ |\n| (1) requests.put()                             | 导入 requests.exceptions 模块中三个异常类                    |\n| (2) requests.delete()                          | from requests.exceptions import ReadTimeout, HTTPError, RequestException |\n| (3) requests.head()                            | ReadTimeout（超时异常） HTTPError（HTTP异常） RequestException（请求异常） |\n| (4) requests.options()                         |                                                              |\n\n​   \n","tags":["爬虫"],"categories":["python"]},{"title":"使用 python 解析 ppt 文档","url":"/dp.github.io/2018/03/15/jppt/","content":"**模块的重载**：考虑到性能的原因，每个模块只被导入一次,放入字典**sys.module**中，如果你改变了模块的内容，你必须重启程序，**python**不支持重新加载或卸载之前导入的模块，可以使用importlib 模块(python默认编码是ASCII编码，当程序出现非ASCII码时，**python**处理常常出现[UnicodeDecodeError:]错误，此时需要自己设置编码，通常为utf-8)。\n\t\t  \n**具体代码：**\n\n```python\nimport sys,importlib\nimportlib.reload(sys)\nimport time\ntime1=time.time()\nimport os.path\nfrom pdfminer.pdfparser import PDFParser,PDFDocument\nfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter\nfrom pdfminer.converter import PDFPageAggregator\nfrom pdfminer.layout import LTTextBoxHorizontal,LAParams\nfrom pdfminer.pdfinterp import PDFTextExtractionNotAllowed\nresult=[]\nclass CPdf2TxtManager():\n    def __init__(self):\n      '''''\n      Constructor\n      '''\n    def changePdfToText(self, filePath):\n      file = open(path, 'rb') # 以二进制读模式打开\n      #用文件对象来创建一个pdf文档分析器\n      praser = PDFParser(file)\n      # 创建一个PDF文档\n      doc = PDFDocument()\n      # 连接分析器 与文档对象\n      praser.set_document(doc)\n      doc.set_parser(praser)\n      # 提供初始化密码\n      # 如果没有密码 就创建一个空的字符串\n      doc.initialize()\n      # 检测文档是否提供txt转换，不提供就忽略\n      if not doc.is_extractable:\n        raise PDFTextExtractionNotAllowed\n      # 创建PDf 资源管理器 来管理共享资源\n      rsrcmgr = PDFResourceManager()\n      # 创建一个PDF设备对象\n      laparams = LAParams()\n      device = PDFPageAggregator(rsrcmgr, laparams=laparams)\n      # 创建一个PDF解释器对象\n      interpreter = PDFPageInterpreter(rsrcmgr, device)\n      pdfStr = ''\n      # 循环遍历列表，每次处理一个page的内容\n      for page in doc.get_pages(): # doc.get_pages() 获取page列表\n        interpreter.process_page(page)\n        # 接受该页面的LTPage对象\n        layout = device.get_result()\n        for x in layout:\n          if hasattr(x, \"get_text\"):\n            # print x.get_text()\n            result.append(x.get_text())\n            fileNames = os.path.splitext(filePath)\n            results = x.get_text()\n            # print(results)\nif __name__ == '__main__':\n  '''''\n   解析pdf 文本，保存到txt文件中\n  '''\n  path = u'D:\\text\\book\\text.pdf'\n  pdf2TxtManager = CPdf2TxtManager()\n  pdf2TxtManager.changePdfToText(path)\n  time2 = time.time()\n  print(u'ok,解析pdf结束!')\n  print(u'总共耗时：' + str(time2 - time1) + 's')\n```\n","tags":["python"],"categories":["python"]},{"title":"nginx","url":"/dp.github.io/2018/03/11/nginx/","content":"\n\n\n## 1.1nginx基本介绍\n\n#### 1.nginx高并发原理(多进程+epool实现高并发)\n\n​\t1.Nginx 在启动后，会有一个 master 进程和多个相互独立的 worker 进程 \n\n​\t2.每个子进程只有一个线程，采用的 IO多路复用模型epoll，实现高并发 \n\n#### 2.**epoll能实现高并发原理**\n\n​\t1.epoll() 中内核则维护一个链表，epoll_wait 方法可以获取到链表长度，不为0就知道文件描述符准备好了 \n\n​\t2.在内核实现中 epoll 是根据每个 sockfd 上面的与设备驱动程序建立起来的回调函数实现的\n\n​\t3.某个 sockfd 上的事件发生时，与它对应的回调函数就会被调用，来把这个 sockfd 加入链表，其他处于“空闲的”状态的则不会 \n\n​\t4.epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术， 避免了复制大量文件描述符带来的开销 \n\n​\t**内存映射（mmap）**：内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行[I/O操作](https://baike.baidu.com/item/I%2FO%E6%93%8D%E4%BD%9C/469761) \n\n#### **3、nginx和apache比较**\n\n​\t(1)nginx相对于apache的优点\n\n​\t\t1.轻量级，同样起web 服务，比apache 占用更少的内存及资源 \n\n​\t\t2.抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 \n\n​\t\t3.高度模块化的设计，编写模块相对简单，社区活跃，各种高性能模块出品迅速啊 \n\n​\t(1)apache相对于nginx的优点\n\n​\t\t1.apache 更为成熟，少 bug ，稳定性好 \n\n​\t\t2.rewrite ，比nginx 的rewrite 强大 \n\n​\t\t3.模块超多，基本想到的都可以找到 \n\n## 1.2 nginx正向代理 & 反向代理\n\n#### **1、正向代理**\n\n​\t1.我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站 \n\n​\t2.于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。 \n\n​\t3.客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。 \n\n​\t4.例如之前使用过这类软件例如CCproxy，http://www.ccproxy.com/ 需要在浏览器中配置代理的地址 。\n\n​\t**正向代理作用：** \n\n​\t\t\t1.访问原来无法访问的资源，如google \n\n​\t\t\t2.可以做缓存，加速访问资源 \n\n​\t\t\t3.对客户端访问授权，上网进行认证 \n\n​\t\t\t4.代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 \n\n#### 2、反向代理\n\n​\t1.反向代理对用户透明，客户端无需任何配置即可访问服务。 \n\n​\t2.实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器。 \n\n​\t3.*并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务  器。* \n\n#### **3、反向代理使用场景**\n\n​\t1.**保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击** \n\n​\t\t**例：**大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 \n\n​\t![img](https://img2018.cnblogs.com/blog/1080958/201903/1080958-20190304113305595-735565325.png) \n\n​\t2.**负载均衡，通过反向代理服务器来优化网站的负载**\n\n​\t![img](https://img2018.cnblogs.com/blog/1080958/201903/1080958-20190304113446914-2073969730.png) \n\n## **3、负载均衡常用配置梳理**\n\n#### 1、轮询（默认）\n\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n\n```\nupstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n```\n\n#### 2、权重 weight\n\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n\n```\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n```\n\n#### 3、IP_hash（ IP绑定）\n\n上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，\n每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。\n我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n\n```\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n```\n\n#### 4、fair（第三方插件）\n\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\n```\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n```\n\n#### 5、url_hash（第三方插件）\n\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n\n```\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```","tags":["nginx"]},{"title":"shell 基础","url":"/dp.github.io/2018/02/14/shell/","content":"\n##### shell 编程概述\n\n```shell\n别名管理:\n1.查看别名\nalias\n\n2.新建别名\nalias myif='nmcli device show ens32'\n\n3.删除别名\nunalias myif\n\n日期管理-date:\ndate '+%Y-%m-%d %T'\nY 年\nm 月\nd 日\nH 时\nM 分\nS 秒\n\nBash重定向:\n1.正确输出 >\n2.正确追加输出 >>\n3.错误输出 2>\n4.错误追加输出 2>>\n5.正确和错误输出 &>\n6.正确和错误追加输出 &>>\n7.正确或错误立即销毁 &>/dev/null\n\nShell编程-基础操作:\n1.变量定义\nname='user1'\n\n2.输出变量\necho $name\necho \"my name is ${name}\"\n\nShell编程-文件测试:\n-d：测试是否为目录（Directory）\n-e：测试目录或文件是否存在（Exist）\n-f：测试是否为文件（File）\n-L：测试是否为符号连接（Link）文件\n\nShell编程-字符串测试:\n=： 字符串内容相同\n!=：字符串内容不同\n-z: 字符串为空\n\nShell编程-数学测试:\n-eq：等于（Equal）\n-ne：不等于（Not Equal）\n-gt：大于（Greater Than）\n-lt：小于（Lesser Than）\n-ge：大于或等于（Greater or Equal）\n-le：小于或等于（Lesser or Equal）\n\nShell编程-逻辑测试:\n&&：逻辑与\n||：逻辑或\n!： 逻辑否\n\nShell编程-用户交互:\nread -p 'please input your name: ' name\necho $name\n\nShell编程实例:\n1.光盘挂载\nif [ ! -e /media/BaseOS ]\nthen\n\tmount /dev/cdrom /media &> /dev/null\n\techo 'cdrom is ok'\nelse\n\techo 'cdrom is ok'\nfi\n\n2.创建用户\nread -p 'please input your name:' name\n\nif [ ! -z $name ]\nthen\n\tread -p 'please input your pass:' pass\n\n\tif [ ! -z $pass ]\n\tthen\n\t\tuseradd $name\n\t\techo $pass | passwd --stdin $name &> /dev/null\n\t\techo \"your name is ${name}，your pass is ${pass}，create is ok\"\n\telse\n\t\techo 'pass is empty'\n\tfi\nelse\n\techo 'name is empty'\nfi\n\n3.内存判断\nmem=`free -m |grep 'Mem'|awk '{print $4}'`\n\nif [ $mem -lt 400 ]\nthen\n\techo \"mem is no,now is ${mem}\"\nelse\n\techo \"mem is yes,now is ${mem}\"\nfi\n\n4.循环输出\nfor name in `cat /etc/passwd | awk -F: '{print $1}'`\ndo\n\techo $name\n\tsleep 1\ndone\n\n```\n\n","tags":["shell"]},{"title":"线程与进程","url":"/dp.github.io/2017/03/17/xjc/","content":"\n#### python\n\n##### 线程与进程的区别：\n\n> 1. 进程是系统进行资源分配和调度的一个单位，线程是进程的一个实体，是cpu调度和分配的基本单位。\n> 2. 进程之间是相互独立的，多进程中，同一个变量，各自有一个备份存在于每个进程中，但互不影响；而同一个进程的多个线程是内存共享的，所有变量都由所有线程共享。\n> 3. 由于进程间是相互独立的，因此一个进程的崩溃不会影响到其他进程；而线程是包含在进程之内的， 线程的崩溃就会引发进程的崩溃，继而导致同一个进程内的其他线程也崩溃。多线程非全局变量是否要加锁；在多线程开发中，全局变量是多个线程都共享的数据，为了防止数据混乱，通常使用互斥锁。而局部变量等是各自线程的，是非共享的，所以不需要使用互斥锁。\n\n\n\n##### 进程：\n\n------\n\n\n\n1. 进程定义\n\n   1. 进程是资源分配最小单位。\n   2. 当一个可执行程序被系统执行（分配内存资源）就变一个进程。\n\n   \n\n2. 进程定义拓展\n\n   1. 程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，这种执行的程序就称为进程。\n   2. 程序和进程的区别就在于：程序是指令集合，它是进程运行的静态描述文本；进程是程序一次执行活动，属于动态概念。\n   3. 在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发执行。\n   4. 进程的出现让每个用户感觉自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。\n   5. 进程之间有自己独立的内存，各进程之间不能相互访问。\n\n   \n\n3. 多道编程概念\n\n   1. 多道编程：在计算机内存中同时存放几道相互独立的程序，它们共享系统资源，相互穿插运行。\n   2. 单道编程：计算机内存中只允许一个程序运行。\n\n   \n\n4. 进程间访问数据的四种方法\n\n   注：不同进程间内存是不共享的，所以相互之间不能访问数据。\n\n   1. 利用Queues实现父进程到子进程（或子进程间）的数据传递。\n   2. 使用管道pipe实现两个进程间数据传递。\n   3. Managers实现多进程间数据共享。\n\n5. 进程池\n\n```python\nfrom multiprocessing import Process . Pool\nimport time, os\n\ndef foo(i):\n    time.sleep(2)\n    print('in the process',os.getpid()) # 打印子进程pid\n    return i + 100\n\ndef call(arg):\n    print('-->exec done:',arg,os.getpid())\n\nif __name__ == '__main__':\n    pool = Pool(3)  # 进程最多允许5个进程放入进程池\n    print('主进程pid:',os.getpid()) # 打印父进程pid\n    for i in range(10):\n        # 用法一，callback作用是指定只有当Foo运行结束后就执行callback调用的函数，父进程调用的\t\t\t\t# callback函数。\n        pool.apply_async(func=foo,args=(i,),callback=call)\n        # 用法二， pool.apply(func=foo,args=(i,))\n        \n\tprint('end')\n    pool.close() # 关闭进程池。\n    pool.join() # 进程池中进程执行完毕后在关闭，如果没有程序直接关闭。\n    \n    \n```\n\n\n\n##### 线程：\n\n------\n\n\n\n1. 线程定义\n   1. 线程是操作系统调度最小单位。\n   2. 它包含在进程之中，是进程实际运作单位。\n   3. 进程本身是无法自己执行的，要操作CPU，必须创建一个进程，线程是一系列指令的集合。\n\n\n\n2. 线程定义拓展\n\n   1. 线程是操作系统能够进行运算调度最小单位。包含在进程之中，是进程实际运作单位。\n   2. 一个线程是一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程并行执行不同任务。\n   3. 无论启动多少个线程，你有多少个CPU，python在执行时只会在同一时刻运行一个线程。\n   4. 所有在同一个进程里的线程是共享一块内存资源的，不同进程间内存空间不同。同一个进程中的各线程可以相互访问资源，线程可以操作同进程中其它线程，但进程仅能操作子进程。\n   5. 两个进程间通信，必须通过一个中间代理。\n\n   \n\n3. 线程锁\n\n   1.  当一个线程对某个资源进行CPU计算的操作时加一个线程锁，只有当前线程计算完成 主动释放锁，其它线程才能操作。\n   2. 这样防止了还未计算完成，释放GIL锁后其它线程对这个资源操作导致混乱问题。\n\n4. Semaphore（信号量）\n\n   1.  互斥锁 同时只允许一个线程更改数据，而 semaphore 是同时允许一定数量的线程更改数据。\n   2. 作用就是同一时刻允许运行的线程数量。\n   3. 比如餐厅由三个座位，那么最多只允许三个人吃饭，后面的人只能等前面的人吃饭完后才能进去吃饭。\n\n5. ****\n\n   **setDaemon(): 守护线程，主线程退出时，需要⼦线程随主线程退出 **\n\n```python\nimport threading\nimport time\nstart_time = time.time()\ndef sayhi(num): #定义每个线程要运行的函数\n\tprint(\"running on number:%s\" %num)\n \ttime.sleep(3)\nfor i in range(50):\n    t = threading.Thread(target=sayhi,args=('t-%s'%i,))\n    t.setDaemon(True) #把当前线程变成守护线程，必须在 t.start()前设置\n    t.start() #启动一个线程，程序不会阻塞\nprint('cost time:',time.time() - start_time)\n```\n\n\n\n6. **线程池实现并发**\n\n\n```python\nimport requests\nfrom concurrent.futures import ThreadPoolExecutor\ndef fetch_request(url):\n \tresult = requests.get(url)\n \tprint(result.text)\nurl_list = [\n 'https://www.baidu.com',\n 'https://www.google.com/', #google 页面会卡住，知道页面超时后这个进程才结束\n 'http://dig.chouti.com/', #chouti 页面内容会直接返回，不会等待 Google 页面的返回\n]\npool = ThreadPoolExecutor(10) # 创建一个线程池，最多开 10 个线程\nfor url in url_list:\n \tpool.submit(fetch_request,url) # 去线程池中获取一个线程，线程去执行 fetch_request 方法\npool.shutdown(True) # 主线程自己关闭，让子线程自己拿任务执行\n```\n\n\n\n##### 协程：\n\n1. **什么是协程**\n   1. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次天调用的状态。\n   2. 协程最主要的作用是 在单线程的条件下实现并发的效果，但实际上还是串行 的（像yield一样）\n\n   \n\n2. **协程缺点（无法利用多核资源）**\n\n   1. 协程本身是个单线程，他不能同时将单个CPU 的多个核 使用，协程需要和进程配合才能运行在多个CPU上，线程阻塞（Blocking）操作会阻塞掉整个程序。\n\n3.  **协程为何能处理⼤并发 1：Greenlet 遇到 I/O ⼿动切换**\n\n   1. 协程之所以快就是因为遇到 I/O 操作就切换（最后只有CPU运算）。\n   2. 其实Gevent模块仅仅是对greenlet的再次封装，将 I/O 间的手动切换变成自动切换。\n\n4. **协程为何能处理⼤并发 2：Gevent 遇到 I/O ⾃动切换** \n\n   1.  Gevent 是⼀个第三⽅库，可以轻松通过 gevent 实现并发同步或异步编程 。\n   2. 在 gevent 中⽤到的主要模式是 Greenlet, 它是以 C 扩展模块形式接⼊ Python 的轻量级协程 。\n   3.  Greenlet 全部运⾏在主程序操作系统进程的内部，但它们被协作式地调度。 \n   4.  Gevent 原理是只要遇到 I/O 操作就会⾃动切换到下⼀个协程 。\n\n5. **使⽤协程处理并发** \n\n   **注：Gevent 只⽤起⼀个线程，当请求发出去后 gevent 就不管,永远就只有⼀个线程⼯作，谁先回来先处理**\n\n   ```python\n   import gevent\n   import requests\n   from gevent import monkey\n   monkey.patch_all()\n   # 这些请求谁先回来就先处理谁\n   def fetch_async(method, url, req_kwargs):\n    \tresponse = requests.request(method=method, url=url, **req_kwargs)\n    \tprint(response.url, response.content)\n   # ##### 发送请求 #####\n   gevent.joinall([\n    gevent.spawn(fetch_async, method='get', url='https://www.python.org/', req_kwargs={}),\n    gevent.spawn(fetch_async, method='get', url='https://www.google.com/', req_kwargs={}),\n    gevent.spawn(fetch_async, method='get', url='https://github.com/', req_kwargs={}),\n   ])\n   ```\n\n   ------\n\n   \n\n##### GIL（全局解释器锁）\n\n**描述Python GIL的概念， 以及它对python多线程的影响？** \n\n**为了解决不同线程同时访问同一资源时，产生了GIL**\n\n**参考：**\n\n> 1. Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。\n> 2. GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。\n> 3. 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100\n> 4. Python使用多进程是可以利用多核的CPU资源的。\n> 5. 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁。\n\n\n\n##### 深拷贝、浅拷贝：\n\n1. **浅拷贝**\n   1. 浅拷贝是对于一个对象的顶层拷贝，拷贝了引用，并没有拷贝内容。 \n\n![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20171023-204000@2x.png)\n\n![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20170420-071018@2x.png)\n\n2. **深拷贝**\n   1. 深拷贝是对于一个对象所有层次的拷贝(递归) \n\n![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20171023-204653@2x.png)\n\n**进一步理解深拷贝**\n\n ![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20171023-205139@2x.png)\n\n![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20171023-205202@2x.png)\n\n3. **注意点**\n\n   **浅拷贝对不可变类型和可变类型的copy不同**\n\n   1. copy.copy对于可变类型，会进行浅拷贝 。\n   2. copy.copy对于不可变类型，不会拷贝，仅仅是指向 。\n\n","tags":["python"],"categories":["python"]},{"title":"扫描并输出局域网占用的 IP 地址","url":"/dp.github.io/2017/03/15/mynew2/","content":"**sys.argv[] 指令:** 是一个程序外部来获取参数的，0是指代码本身的路径。可以通过外部来获取多个参数，类似列表。所以使用[]来获取。\n\n\n**argparse** : \n是命令行解析模块；sys.argv[]是通过外部传的参数，无法通过编辑器直接运行，而是通过dos命令行里操作；两者可以结合使用。\n\n\n\n```python\nimport sys,  socket\nimport threading\n\nlist_of_name = []\nlist_of_ip = []\nthread_pool = []\n\ndef showInfo():\n    print(\"\"\"\n        命令格式：LAN_ip_hostname -all startip\n                LAN_ip_hostname -ip ipaddr\n                LAN_ip_hostname -hostname hostname\n        说明：   -all 扫描局域网中所有IP对应的 hostname，需要起始IP，如192.168.0.1\n                -ip 获取指定ip的hostname\n                -hostname 根据主机名，得到ip地址\n    \"\"\")\n\ndef LanAll(startip):\n    index = startip.rfind('.') # 找出最右边 . 的索引\n    ipfirstpart = startip[0:index + 1] # ip 地址中前三位，如 192.168.0.1\n    intstart = int(startip[index + 1])  # ip 地址最后一位，转为int\n    f = range(intstart,255)\n    global g_mutex\n    g_mutex = threading.Lock()  # 初始化互斥锁\n    for iplastpart in f:\n        targetip = ipfirstpart + str(iplastpart) # 拼接ip\n        # 创建线程对象，存为 thread 线程要执行的函数由 target 指定，args 指定参数，\n        # 可以是元组~。线程号从 1 开始\n        thread = threading.Thread(target=Lanlp2Name,args=(targetip,))\n        thread_pool.append(thread)\n        thread.start()\n    # 阻塞主线程 collect all threads\n    for pos in f:\n        threading.Thread.join(thread_pool[pos - intstart])\n    #输出结果\n    hosts = range(0,len(list_of_name))\n    for host in hosts:\n        print(list_of_ip[host],'======>',list_of_name[host])\n    print('Find',len(list_of_name),'hosts.Done!')\ndef Lanlp2Name(ip):\n    try:\n        (name, aliaslist,addresslist) = socket.gethostbyaddr(ip)\n    except:\n        return\n    global g_mutex # 再次声明\n    g_mutex.acquire()  # 上锁\n    list_of_name.append(name)\n    list_of_ip.append(ip)\n    g_mutex.release()  # 释放锁\ndef LanipToName(ip):\n    try:\n        (name, aliaslist,addresslist) = socket.gethostbyaddr(ip)\n    except:\n        return\n    print('%s ======>%s'%(addresslist,name))\ndef LanName2IP(name):\n    targetip = socket.gethostbyname(name)\n    print(name,'=====>',targetip)\nif __name__ == '__main__':\n    if len(sys.argv) < 3:\n        print('参数错误')\n        showInfo()\n        exit(1)\n    cmds = ['-all','-ip','-hostname']\n    cmd = sys.argv[1] # 命令格式\n    target = sys.argv[2] # ip地址\n    if 0 == cmds.count(cmd):\n        print('参数错误啊')\n        showInfo()\n        exit(1)\n    else:\n        print('开始工作请等待...')\n        if cmd == '-all':\n            LanAll(target) # 输出所有的 主机 与 ip 名\n        elif cmd  == '-ip':\n            LanipToName(target) # 根据当前IP 输出主机名\n        elif cmd == '-hostname':\n            LanName2IP(target)  # 根据当前主机名输出ip\n```\n\n\n\n","tags":["网络"],"categories":["socket"]},{"title":"模拟网络嗅探器","url":"/dp.github.io/2017/02/06/mynew1/","content":"\n> struct: 按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;按照指定格式将字节流转换为Python指定的数据类型;\n>\n\n\n\n> ICMP协议：ICMP协议用于IP主机、路由器之间传递控制消息，这里的控制消息可以包括很多种:数据报错误信息、网络状况信息、主机状况信息等;虽然这些控制消息虽然并不传输用户数据，但对于用户数据报的有效递交起着重要作用，从TCP//IP的分层结构看ICMP属于网络层,它配合着IP数据报的提交,提高IP数据报递交的可靠性。ICMP是封装在IP数据报中进行发送的，从这点看来 ICMP 协议又有点像一个传输层协议，其实不然，因为ICMP报文的目的不是目的主机上的某个应用程序，它不为应用程序提供传输服务，ICMP报文的目的是目的主机上的网络层处理软件。简单的来说,ICMP协议就像奔波于网络中的一名医生,它能及时检测并汇报网络中可能存在的问题，为解决网络错误或拥塞提供了最有效的手段。\n>\n\n\n\n```python\nimport socket\nimport os\nimport struct\nfrom ctypes import *\n\n\nhost = '192.168.249.1'\n\nclass IP(Structure):\n    _fields = [\n        (\"ihl\", c_ubyte, 4),\n        (\"version\", c_ubyte, 4),\n        (\"tos\", c_ubyte),\n        (\"len\", c_ushort),\n        (\"id\", c_ushort),\n        (\"offset\", c_ushort),\n        (\"ttl\", c_ubyte),\n        (\"protocol_num\", c_ubyte),\n        (\"sum\", c_ushort),\n        (\"src\", c_ulong),\n        (\"dst\", c_ulong)\n        ]\n    def __new__(self, socket_buffer=None):\n        return self.from_buffer_copy(socket_buffer)\n\n    def __init__(self,socket_buffer=None):\n        self.protocol_map = {1:'ICMP', 6:'TCP', 17:'UDP'}\n        self.src_address = socket.inet_ntoa(struct.pack(\"<L\",self.src))\n        self.dst_address = socket.inet_ntoa(struct.pack(\"<L\",self.dst))\n\n        try:\n            self.protocol = self.protocol_map[self.protocol_num]\n\n        except:\n            self.protocol = str(self.protocol_num)\n\nif os.name == \"nt\":\n    socket_protocol = socket.IPPROTO_IP\n\nelse:\n    socket_protocol = socket.IPPROTO_ICMP\n\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)\n\nsniffer.bind((host,0))\n\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL,1)\n\nif os.name == 'nt':\n    sniffer.ioctl(socket.SIO_RCVALL,socket.RCVALL_ON)\n\ntry:\n    while True:\n        raw_buffer = sniffer.recvfrom(65565)[0]\n        ip_header = IP(raw_buffer[0:20])\n        print(\"Protocol:%s %s -> %s\"%(ip_header.protocol,ip_header.src_address,ip_header.dst_address))\nexcept:\n    if os.name == \"nt\":\n        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\n    print('出现错误！')\n```\n\n\n\n\n\n\n\n","tags":["网络"],"categories":["socket"]},{"title":"osi 七层协议模型","url":"/dp.github.io/2016/06/03/osi/","content":"\n##### OSI 七层模型各层的协议以及功能\n\n\n\n1. **物理层：**主要定义物理设备标准，比如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0  转化为电流强弱来进行传输，到达目的后在转换为1、0，也就是我们常说的数模转换与数模转换），这一层的数据叫做比特。\n2. **数据链路层：**定义了如何让格式化数据进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。（物理寻址，将比特流换成逻辑传输）\n3. **网络层：**在位于不同地理位置的网络中的两个主机系统之间提供链接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。\n4. **传输层：**定义了一些传输数据的协议和端口号（www端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，对于传输的可靠性要求高以及数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，对于传输的可靠性要求不高，数据量小的数据，比如QQ聊天数据就是通过这种方式传输的），主要是将从下层接收的数据进行分段和传输，到达目的地址后在进行重组，常常把这一层数据叫做段。\n5. **会话层：**通过传输层（端口号：接收端口和传输端口）建立数据传输的通道，主要是在系统之间发起会话或者接收会话请求（设备之间需要相互通信可以是IP也可以是MAC或者是主机名）。\n6. **表示层：**可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，pc程序与另一台计算机进行通信，其中一台计算机使用扩展二十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同字符。如有必要，表示层会通过使用一种通用格式来实现多种数据格式之间的转换。\n7. **应用层：**是最靠近用户的OSI层，这一层为用户的应用程序、各种各样的应用程序（例如：电子邮件、文件传输和终端仿真）提供网络服务。\n\n\n\n\n\n##### 每一层协议分类\n\n- 应用层\n  - DHCP（动态主机分配协议）\n  - DNS（域名解析）\n  - FTP（File Transfer Protocol 文件传输协议）\n  - Gopher （英文原义：The Internet Gopher Protocol 中文释义：（RFC-1436）网际Gopher协议） \n  - HTTP（Hypertext Transfer Protocol   超文本传输协议 ）\n  - IMAP4 (Internet Message Access Protocol 4  即 Internet信息访问协议的第4版本 ) \n  - IRC （Internet Relay Chat ）网络聊天协议 \n  - NNTP （Network News Transport Protocol）RFC-977）网络新闻传输协议\n  - XMPP 可扩展消息处理现场协议\n  -  POP3 (Post Office Protocol 3)即邮局协议的第3个版本\n  -  SIP 信令控制协议\n  -  SMTP （Simple Mail Transfer Protocol）即简单邮件传输协议\n  -  SNMP (Simple Network Management Protocol,简单网络管理协议)\n  -  SSH （Secure Shell）安全外壳协议\n  -  SSL: 安全套接字层协议；\n  - TELNET 远程登录协议\n  -  RPC （Remote Procedure Call Protocol）（RFC-1831）远程过程调用协议\n  -  RTCP （RTP Control Protocol）RTP 控制协议\n  -  RTSP （Real Time Streaming Protocol）实时流传输协议\n  -  TLS （Transport Layer Security Protocol）传输层安全协议\n  -  SDP( Session Description Protocol）会话描述协议\n  -  SOAP （Simple Object Access Protocol）简单对象访问协议\n  -  GTP 通用数据传输平台\n  -  STUN （Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议\n  -  NTP （Network Time Protocol）网络校时协议\n- 传输层\n  - TCP（Transmission Control Protocol）传输控制协议\n  - UDP (User Datagram Protocol）用户数据报协议\n  - DCCP （Datagram Congestion Control Protocol）数据报拥塞控制协议\n  - SCTP（STREAM CONTROL TRANSMISSION PROTOCOL）流控制传输协议\n  - RTP(Real-time Transport Protocol或简写RTP）实时传送协议\n  - RSVP （Resource ReSer Vation Protocol）资源预留协议\n  - PPTP ( Point to Point Tunneling Protocol）点对点隧道协议 \n- 网络层\n  - IP(IPv4 · IPv6) Internet Protocol（网络之间互连的协议） \n  - ARP : Address Resolution Protocol即地址解析协议，实现通过IP地址得知其物理地址。\n  - RARP :Reverse Address Resolution Protocol 反向地址转换协议允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。 \n  - ICMP :（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。\n  -  ICMPv6: IGMP :Internet 组管理协议（IGMP）是因特网协议家族中的一个组播协议，用于IP 主机向任一个直接相邻的路由器报告他们的组成员情况。\n  -  RIP : 路由信息协议（RIP）是一种在网关与主机之间交换路由选择信息的标准。 \n  - OSPF : (Open Shortest Path First开放式最短路径优先)\n  - BGP :（Border Gateway Protocol ）边界网关协议，用来连接Internet上独立系统的路由选择协议\n  - IS-IS:（Intermediate System to Intermediate System Routing Protocol）中间系统到中间系统的路由选择协议\n  - IPsec:“Internet 协议安全性”是一种开放标准的框架结构，通过使用加密的安全服务以确保在 Internet 协议 (IP) 网络上进行保密而安全的通讯。 \n- 数据链路层\n  - 802.11 · 802.16 · Wi-Fi · WiMAX · ATM · DTM · 令牌环 · 以太网 · FDDI · 帧中继 · GPRS · EVDO · HSPA · HDLC · PPP · L2TP · ISDN \n- 物理层\n  - 以太网物理层 · 调制解调器 · PLC · SONET/SDH · G.709 · 光导纤维 · 同轴电缆 · 双绞线 ","tags":["网络编程"]},{"title":"python 基础","url":"/dp.github.io/2016/05/01/sumup/","content":"\n## **Python2 与 3的区别**\n\nprint语句被python3废弃，改为print函数\n\nPython3中字符串是Unicode (utf-8)编码、python2中是ASCII编码\n\n异常处理 Python2中try:...except Exception, e:...，在Python3中改为了try:...except Exception as e:...\n\nPython3中不再使用xrange方法，只有range方法。\n\nrange在Python2中返回列表，而在Python3中返回range可迭代对象。\n\npython 2 中通过input输入的类型是int，只有通过raw_input()输入的类型才是str。\n\n## **进程 线程 协程**\n\n### 进程\n\n进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。\n\n进程是是资源分配的最小单位 运行在内存中\n\n每个进程最少有一个线程,进程不干活让线程干\n\n进程可以通过派生新的进程来执行其它任务，不过每个进程还是都拥有自己的内存和数据栈等。\n\n一个进程具有:就绪，运行，中断，僵死，结束等状态(不同操作系统不一样)。\n\n进程支持并发和并行\n\n#### 进程通信\n\n进程之间数据不共享  所以需要进程通信\n\n通信的三种方式\n\n​\t1 进程队列queue\n\n​\t2 管道pipe\n\n​\t3 共享数据manage\n\n#### 进程说明\n\n多个进程可以在不同的 CPU 上运行，互不干扰\n\n同一个CPU上，可以运行多个进程，由操作系统来自动分配时间片\n\n#### 进程池\n\n开多进程是为了并发，通常有几个cpu核心就开几个进程，但是进程开多了会影响效率，主要体现在切换的开销，所以引入进程池限制进程的数量。\n\n进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。\n\n### 线程\n\n线程，是在进程中执行的代码。线程之间 数据共享\n\n一个进程下可以运行多个线程，这些线程之间共享主进程内申请的操作系统资源。\n\n线程是系统调度的最小单位  \n\n#### 常用方法\n\n##### join()方法\n\n​\t实现所有线程都执行结束后再执行主线程\n\n​\t如果一个线程或者在函数执行的过程中调用另一个线程，并且希望待其完成操作后才能执行，   那么在\t调用线程的时就可以使用被调线程的join方法join([timeout]) timeout：可选参数，线程运行的最长时间\n\n##### isAlive()方法\n\n​\t查看线程是否还在运行\n\n##### getName()方法\n\n​\t获得线程名\n\n##### setDaemon()方法\n\n​\t主线程退出时，需要子线程随主线程退出，则设置子线程的setDaemon()     也叫守护线程\n\n#### 线程锁\n\n线程锁也叫用户锁 也叫互斥锁、当前线程还未操作完成前其他所有线程都无法对其操作，即使已经释放了GIL锁\n\n#### 线程特性\n\n线程，必须在一个存在的进程中启动运行\n\n线程使用进程获得的系统资源，不会像进程那样需要申请CPU等资源\n\n线程无法给予公平执行时间，它可以被其他线程抢占，而进程按照操作系统的设定分配执行时间\n\n#### 线程池\n\n系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。\n\n线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。\n\n\n\n### 进程和线程的区别\n\n一个进程中的各个线程与主进程共享相同的资源，与进程间互相独立相比，线程之间信息共享和通信更加容易\n\n线程一般以并发执行，正是由于这种并发和数据共享机制，使多任务间的协作成为可能。\n\n进程一般以并行执行，这种并行能使得程序能同时在多个CPU上运行;\n\n### 协程\n\n协程能在单线程的条件下支持并发,能遇IO自动切换、将网络数据或磁盘数据写入到内存就是一个IO操作\n\n协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用，且看似像多线程 实际就是单线程\n\n协程由于由程序主动控制切换，没有线程切换的开销，所以执行效率极高。对于IO密集型任务非常适用，如果是cpu密集型，推荐多进程+协程的方式。\n\n#### 协程优点\n\n1   无需线程上下文切换的开销   \n\n2   不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突\n\n3   单线程内就可以实现并发的效果，最大限度地利用cpu\n\n#### 协程缺点\n\n无法利用多核资源：**协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上**,协程需要和进程配合才能运行在多CPU上\n\n**线程阻塞（Blocking）操作（如IO时）会阻塞掉整个程序**\n\n#### 协程为何能处理并发\n\n##### **Greenlet**\n\n遇IO操作  手动切换 、是c语言开发的\n\n##### **Gevent**\n\nGevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程\n\n其实Gevent模块仅仅是对greenlet的再封装，将I/O间的手动切换变成自动切换\n\nGevent原理是只要遇到I/O操作就会自动切换到下一个协程\n\n#### 猴子补丁\n\n用过gevent就会知道,会在最开头的地方gevent.monkey.patch_all();\n\n作用是把标准库中的thread/socket等给替换掉.无需修改任何代码,把它变成了非阻塞\n\n#### 说明\n\n协程间是协同调度的，这使得并发量数万以上的时候，协程的性能是远远高于线程。注意这里也是“并发”，不是“并行”。 协程还有gevent和greenlet 2个第三方库、greenlet是c语言开发的、是遇IO手动切换、 gevent内封装了greenlet  遇IO自动切换\n\ngreenlet框架封装了yield语句、挂起函数，直到稍后使用next()或send()操作进行恢复为止\n\n## **GIL全局解释器锁**\n\nGIL 保证同一时间内只有一个线程在执行、GIL并不是Python的特性   \n\nGIL只存在于使用C语言编写的解释器CPython中\n\n#### 有了GiL锁为何需要线程锁\n\n因为CPU给当前线程分配了时间、时间结束后线程任务没完成所以需要线程锁\n\n#### GiL有什么影响\n\nGIL无疑就是一把全局排他锁。毫无疑问全局锁的存在会对多线程的效率有不小影响。甚至就几乎等于Python是个单线程的程序。\n\n##### 排他锁\n\n若事务T对数据对象A加上X锁，则只允许T读取和修改A\n其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。\n\n#### 避免GiL带来的影响\n\n##### 方法一\n\n用进程+协程 代替 多线程的方式 在多进程中，由于每个进程都是独立的存在，所以每个进程内的线程都拥有独立的GIL锁，互不影响。但是，由于进程之间是独立的存在，所以进程间通信就需要通过队列的方式来实现。\n\n##### 方法二\n\n更换解释器\n\n## **迭代器**\n\n#### 迭代器的定义\n\n迭代器是访问集合内元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束。\n\n凡是可作用于`next()`函数的对象都是迭代器（`Iterator）`类型，它们表示一个惰性计算的序列；\n\n#### 迭代器的2方法\n\nnext可以返回容器的下一个元素\n\n```python\na = iter([1,2,])              #生成一个迭代器\nprint(a.__next__())\nprint(a.__next__())\nprint(a.__next__())           #在这一步会引发  “StopIteration” 的异常\n```\n\n__ iter __返回迭代器本身\n\n\n\n#### 可迭代对象\n\n​\t凡是可作用于`for`循环的对象都是可迭代的（Iterable）类型；\n\n#### 小结\n\n \t一个实现了__iter__方法的对象是可迭代的，一个实现next方法的对象是迭代器\n\n\n\n## 生成器\n\n### 工作原理\n\n生成器是这样一个函数，它记住上一次返回时在函数体中的位置。\n\n对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。\n\n\n\n##### 生成器的定义\n\n生成器，即生成一个容器。\n在Python中，**一边循环，一边计算的机制，称为生成器。**\n生成器可以理解为一种数据类型，这种数据类型自动实现了迭代器协议（其他数据类型需要调用自己的内置iter（）方法或__iter__()的内置函数），\n所以，生成器就是一个可迭代对象。\n\n##### 生成器的作用\n\n1. 通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的。\n\n2. 如: 创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n\n3. 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？\n\n4. 这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n\n5. 创建一个生成器\n\n   ```python\n   print( [i*2 for i in range(10)] )             #列表生成式： [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n   print( (i*2 for i in range(10)) )             #<generator object <genexpr> at0x005A3690>\n   \n   #获取生成器内元素\n   g = (i*2 for i in range(10))\n   print( g.__next__() )               # 0\n   print( g.__next__() )               # 2\n   ```\n\n### yield运行机制\n\n在Python中，yield就是一个生成器。  如果在函数内使用了yield关键字时,这个函数就是一个生成器\n\n当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把yield 的参数给你，之后生成器就不会往下继续运行。\n\n当你问他要下一个数时，他会从上次的状态开始运行，直至出现yield语句，把参数给你，之后停下。如此反复\n\n每当调用一次迭代器的next函数，生成器函数运行到yield之处，返回yield后面的值且在这个地方暂停，所有的状态都会被保持住，直到下次next函数被调用，或者碰到异常循环退出。\n\n### 手写斐波那契\n\n```python\ndef fbnq(n):\n    a,b=0,1\n    while n>a:\n        yield a\n        a,b=b,a+b\nif __name__ == '__main__':\n    f=fbnq(9)\n    print(next(f))    #打印结果 0\n    print(next(f))    #打印结果 1\n```\n\n\n\n## 装饰器\n\n### 装饰器作用\n\n装饰器是在不修改源代码的情况下为其添加新的功能、 装饰器是基于闭包实现的 \n\n装饰器原则:\n\n​\t不能修改被装饰函数的源代码\n​\t不能修改被装饰函数的调用方式\n\n### 手写三级装饰器\n\n```python\nimport time\nuser,passwd = 'aaa','123'\ndef auth(auth_type):\n    print(\"auth func:\",auth_type)\n    def outer_wrapper(func):\n        def wrapper(*args, **kwargs):\n            print(\"wrapper func args:\", *args, **kwargs)\n            if auth_type == \"local\":\n                username = input(\"Username:\").strip()\n                password = input(\"Password:\").strip()\n                if user == username and passwd == password:\n                    print(\"\\033[32;1mUser has passed authentication\\033[0m\")\n                    res = func(*args, **kwargs)  # from home\n                    print(\"---after authenticaion \")\n                    return res\n                else:\n                    exit(\"\\033[31;1mInvalid username or password\\033[0m\")\n            elif auth_type == \"ldap\":\n                print(\"搞毛线ldap,不会。。。。\")\n\n        return wrapper\n    return outer_wrapper\n\ndef index():\n    print(\"welcome to index page\")\n@auth(auth_type=\"local\") # home = wrapper()\ndef home():\n    print(\"welcome to home  page\")\n    return \"from home\"\n\n@auth(auth_type=\"ldap\")\ndef bbs():\n    print(\"welcome to bbs  page\")\n\nindex()\nprint(home()) #wrapper()\nbbs()\n```\n\n## 闭包\n\n在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用，这样就构成了一个闭包\n\n但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。\n\n#### 闭包特点\n\n1. 必须有一个内嵌函数\n2. 内嵌函数必须引用外部函数中的变量\n3. 外部函数的返回值必须是内嵌函数\n\n## 四大高阶函数\n\n#### MAP\n\nmap(func, iter)函数：Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回 \n\n第一个参数接收一个函数名，第二个参数接收一个可迭代对象\n\n功能:将传入的函数依次作用于序列中的每一个元素,并把结果作为一个新的迭代器返回.\n注意:当传入map的序列只有一个的时候,传入的函数,有且只有一个参数.当map的序列有多个的情况下,得到的迭代长度与序列中最短的那个列表长度相同\n\n```python\ndef a(b):\n    return b*b   #这里可以使用 算术运算符 任意一种\nA=map(a,[1,2,3,4,5]) #map里2个参数 一个是函数名 一个是可迭代对象\nprint(list(A)) #把变量A 强转为列表  输出结果[1, 4, 9, 16, 25]\nprint(type(A)) #输出结果 <map object at 0x00000297DFE25080>\n```\n\n\n\n#### Reduce\n\nreduce(func, iter)函数 ：会对参数序列中元素进行累积\n参数一:要传入的函数名 \n参数二:序列 \n功能:一个函数作用序列上,而且此函数必须接受两个参数, reduce把这次作用的结果,继续与序列中的下一个元素进行累计运算. \n\n```python\n#reduc 函数  使用reduce必须先导入模块\nfrom functools import reduce\ndef e (f,g):\n    return f+g\nE=reduce(e,(1,2,3,4,5))\nprint(E) #这里不能用list强转   输出结果 15\n```\n\n\n\n#### Filter\n\nfilter(func, iter) 函数 ：用于过滤序列 \n参数一:函数名 \n参数二:序列 \n功能:将序列中的每一个元素作用于func,根据func返回True或者False决定是否保留该元素. 当func返回True,保留该元素,返回False的时候去除该元素. \n\n```python\n#一行代码过滤 奇偶数   面试高频题   \na = filter(lambda x:x%2 == 1,range(1,101))\nprint(list(a))    \n```\n\n\n\n#### Sorted\n\nsorted(iterable,key,reverse)函数 ：排序参数一:必须可迭代对象,[用于比较的序列]\n参数二:用于比较函数的时候,比较什么由key来决定[key有默认值]\n参数三:reverse = True[降序], reverse = False[升序,默认升序]返回值,返回的一个可迭代对象.\n\n```python\nmy_list=[2,5,1,-56,9,100,34,0,-101]\nprint(sorted(my_list))  #默认从小到大排序\nprint(sorted(my_list,reverse=True))  #从大到小排序\nprint(sorted(my_list,reverse=False))  #从小到大排序\nprint(sorted(my_list,key=abs)) #使用key=系统函数abs（绝对值，负数变正数） 从小到大排序\n```\n\n\n\n#### Lambda(匿名函数)\n\n lambda只是一个表达式，函数体比def简单很多。\n\n lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。\n\nlambda表达式是起到一个函数速写的作用。允许在代码内嵌入一个函数的定义。\n\n **格式：**lambda的一般形式是关键字lambda后面跟一个或多个参数，紧跟一个冒号，之后是一个表达式。\n\n```python\nm=lambda i:i\nlista=sorted([1,-2,3,-4,5,-6],key=abs)\nprint(lista)   #结果: [1, -2, 3, -4, 5, -6]\n\n\n# 利用 filter、lambda表达式 获取列表中元素小于33的所有元素\nl1= [11,22,33,44,55]\na = filter(lambda x: x<33, l1)\nprint(list(a))\n```\n\n\n\n## 面向对象\n\n### 面向对象方法\n\n#### 静态方法\n\n​\t**作用**：静态方法可以更好的组织代码，防止代码变大后变得比较混乱。  \n\n​\t**特性:**  静态方法只是名义上归类管理，实际上在静态方法里访问不了类或则实例中的任何属性\n\n​\t **静态方法使用场景：**\n　　　　经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下 需要用到静态方法. \n　　　　比如更改环境变量或者修改其他类的属性等能用到静态方法. \n　　　　这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难.\n\n​\t**调用方式:**  既可以被类直接调用，也可以通过实例调用\n\n```python\nclass Dog(object):\n    def __init__(self,name):\n        self.name = name\n    @staticmethod\n    def eat():\n        print(\"I am a static method\")\nd = Dog(\"ChenRonghua\")\nd.eat()                       #方法1：使用实例调用\nDog.eat()                   #方法2：使用类直接调用\n```\n\n\n\n#### 类方法\n\n**作用**：无需实例化直接被类调用  \n\n**特性:**  类方法只能访问类变量，不能访问实例变量\n\n**类方法使用场景：** 当我们还未创建实例，但是需要调用类中的方法\n\n**调用方式:**  既可以被类直接调用，也可以通过实例调用\n\n```python\nclass Dog(object):\n    name = '类变量' #在这里如果不定义类变量仅定义实例变量依然报错\n    def __init__(self,name):\n        self.name = '实例变量'\n        self.name = name\n    @classmethod\n    def eat(self,food):\n        print(\"%s is eating %s\"%(self.name,food))\nDog.eat('baozi')                   #方法1：使用类直接调用\nd = Dog(\"ChenRonghua\")          \nd.eat(\"包子\")                      #方法2：使用实例d调用\n```\n\n\n\n\n\n#### 属性方法\n\n**作用：**属性方法把一个方法变成一个属性，隐藏了实现细节,调用时不必加括号直接d.eat即可调用self.eat()方法\n\n\n\n```python\nclass Dog(object):\n    def __init__(self, name):\n        self.name = name\n\n    @property\n    def eat(self):\n        print(\" %s is eating\" % self.name)\nd = Dog(\"ChenRonghua\")\nd.eat()\n# 调用会出以下错误， 说NoneType is not callable, 因为eat此时已经变成一个静态属性了， \n# 不是方法了， 想调用已经不需要加()号了，直接d.eat就可以了\n```\n\n\n\n\n\n#### 特殊(魔术)方法\n\n**__ doc __**　 表示类的描述信息\n\n**__ call __**     对象后面加括号，触发执行\n\n **__ str __**     如果一个类中定义了__ str __方法，在打印对象时，默认输出该方法的返回值 \n\n**__ dict __**     查看类或对象中的所有成员\n\n**__new__和__init__的区别**\n\n　　　　**1、** __new__是一个静态方法,而__init__是一个实例方法.\n　　　　**2、** __new__方法会返回一个创建的实例,而__init__什么都不返回.\n　　　　**3、** 只有在__new__返回一个cls的实例时后面的__init__才能被调用.\n　　　　**4、** 当创建一个新实例时调用__new__,初始化一个实例时用__init__.\n\n### 单例模式\n\n1. 单例模式：永远用一个对象得实例，避免新建太多实例浪费资源         \n\n   保证一个类只有一个实例，并提供一个访问他的全局访问点\n\n2. 实质：使用__new__方法新建类对象时先判断是否已经建立过，如果建过就使用已有的对象\n\n3. 使用场景：如果每个对象内部封装的值都相同就可以用单例模式\n\n```python\nclass Foo(object):\n   instance = None\n   def __init__(self):\n      self.name = 'alex'\n\n   def __new__(cls, *args, **kwargs):\n      if Foo.instance:\n         return Foo.instance\n      else:\n         Foo.instance = object.__new__(cls,*args,**kwargs)\n         return Foo.instance\n\nobj1 = Foo()       # obj1和obj2获取的就是__new__方法返回的内容\nobj2 = Foo()\nprint(obj1,obj2)   \n# 运行结果： <__main__.Foo object at 0x00D3B450>    <__main__.Foo object at 0x00D3B450>\n\n# 运行结果说明：\n# 这可以看到我们新建的两个Foo()对象内存地址相同，说明使用的•同一个类，没有重复建立类\n```\n\n##### 优点\n\n1、\t对唯一实例的受控访问（比如写日志时的日志句柄）\n2、\t单例模式相当于全局变量，单例模式防止了命名空间被污染\n\n### 面向对象属性\n\n#### 公有属性\n\n公有属性：在内存中仅存一份\n\n#### 普通属性\n\n普通属性：每个实例对象在内存存一份\n\n#### 私有属性\n\n私有属性：实例在外部无法调用\n\n### 封装 继承 多态\n\n#### 封装\n\n**封装（隐藏实现细节）**\n\n1．在类中对数据的赋值、内部调用对外部用户是透明的\n\n1. 这使类变成了一个胶囊或容器，里面包含着类的数据和方法\n\n**作用**\n\n　　1）防止数据被随意修改\n\n　　2）使外部程序不需要关注对象内部的构造，只需要通过对外提供的接口进行直接访问\n\n#### 继承\n\n**继承（代码重用）**\n\n1. 一个类可以派生出子类，在这个父类里定义的属性、方法自动被子 类继承\n2. 比如CS中的警察和恐怖分子，可以将两个角色的相同点写到一个父类中，然后同时去继承它\n3. 使用经典类： Person.__init__(self,name,age) 并重写写父类Person的构造方法，实现，先覆盖，再继承，再重构\n\n#### 多态\n\n **多态（接口重用）**\n\n1．多态是面向对象的重要特性,简单点说:“一个接口，多种实现”\n\n1. 指一个基类中派生出了不同的子类，且每个子类在继承同样的方法名的同时又对父类的方法做了不同的实现\n2. 这就是同一种事物表现出的多种形态\n3. 比如黄种人继承了人talk这个功能，但是他说的是中文，而美国人  的talk是英文，但是他们是同样的talk\n\n作用：简单的讲就是允许父类调用子类的方法\n\n\n\n### 新式类-经典类的区别\n\n##### 写法上的区别\n\n​\t❶经典类   没有继承object , 新式类 继承了object\n\n​\t❷多继承中，新式类采用广度优先搜索,而旧式类是采用深度优先搜索，python3中全是广度查询\n\n​\t❸**在继承中新式类和经典类写法区别**\n\n```python\n\tSchoolMember.__init__(self,name,age,sex)                      #经典类写法\n\tsuper(Teacher,self).__init__(name,age,sex)                    #新式类写法\n```\n\n\n\n### 反射\n\n通过字符串找到对应请求( get  post   delete 等...)\n\n### 三元运算\n\n1. **三元运算格式：**  result=值1 if x<y else 值2    if条件成立result=1,否则result=2\n2. **作用：**三元运算，又称三目运算，主要作用是减少代码量，是对简单的条件语句的缩写\n\n```python\n#一个简单的三元运算\na=name='小草' if1=1 else '小花'\nprint(a)  # 小草\n\n#三元运算 + lambda\nf = lambda x:x if x % 2 != 0 else x + 100\nprint(f(10))                    # 110\n```\n\n\n\n## IO多路复用\n\n无论是sellect、poll、epoll他们三个都是在I/O多路复用中检测多个socket链接，与数据从内核态到数据态没有什么关系\n\nWindows下只支持select   如果是Linux最好使用epoll\n\n\n\n#### select\n\nselect 能监控数量有限，不能告诉用户程序具体哪个连接有数据\n\n1. select目前几乎在所有的平台上支持，其良好**跨平台**支持也是它的一个优点，\n\n   事实上从现在看来，这也是它所剩不多的优点之一\n\n2. select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，\n\n   在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制\n\n3. select监控socket连接时不能准确告诉用户是哪个，比如：现在用socket监控10000链接，如果其中有一个\n\n 链接有数据了，select就会告诉用户程序，你有socket来数据了，那样就只能自己循环10000次判断哪个活跃\n\n#### Poll\n\n poll和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制\n\n#### Epoll\n\nepoll被认为是linux下性能最好的多路io就绪通知方法\n\nepoll直到Linux2.6（centos6以后）才出现了由内核直接支持\n\nepoll最重要的优点是他可以直接监听哪些是活跃数据,并将其放在链表中返回\n\n##### epoll为什么能实现高并发\n\n1. epoll() 中内核则维护一个链表，epoll_wait 直接检查链表是不是空就知道是否有文件描述符准备好了。\n2. 在内核实现中 epoll 是根据每个 sockfd 上面的与设备驱动程序建立起来的回调函数实现的。\n\n*3. 某个 sockfd 上的事件发生时，与它对应的回调函数就会被调用，来把这个 sockfd 加入链表，其他处于“空      闲的”状态的则不会。*\n\n1. epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术， 避免了复制大量文件描述符带来的开销\n\n**内存映射（mmap）**：内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行I/O操作\n\n\n\n## 垃圾回收机制\n\n#### 引用计数\n\n##### 原理\n\n1. 当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1\n2. 当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。\n\n##### 优 缺 点\n\n优点\n\n引用计数有一个很大的优点，即实时性，任何内存，一旦没有指向它的引用，就会被立即回收，而其他的垃圾收集技术必须在某种特殊条件下才能进行无效内存的回收。\n\n缺点\n\n1. 引用计数机制所带来的维护引用计数的额外操作与Python运行中所进行的内存分配和释放，引用赋值的次数是成正比的，\n2. 这显然比其它那些垃圾收集技术所带来的额外操作只是与待回收的内存数量有关的效率要低。\n3. 同时，因为对象之间相互引用，每个对象的引用都不会为0，所以这些对象所占用的内存始终都不会被释放掉。\n\n#### 标记清楚\n\n##### 原理\n\n1. 基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点\n2. 以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放\n\n##### 说明\n\n1. 标记－清除: 只关注那些可能会产生循环引用的对象\n2. Python中的循环引用总是发生在container(容器) 对象之间，也就是能够在内部持有其它对象的对象，比如list、dict、class等等。\n3. 这也使得该方法带来的开销只依赖于container对象的的数量.\n\n标记和清除的过程效率不高\n\n#### 分代回收\n\n1. 将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。\n2. 活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。\n3. 如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量, 如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。\n\n\n\n## Tcp与Udp\n\n\n\nTCP与UDP比较\n\n1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n   CP提供可靠的服务，也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;\n\n```\n            UDP尽最大努力交付，即不保证可靠交付\n                    　　　　　　3. Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。\n              　　　　　　4.  UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。\n              　　　　　　5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\n                                　　　　　　6.  TCP对系统资源要求较多，UDP对系统资源要求较少。\n```\n\n注：UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频等\n\n#### 三次握手四次挥手\n\nTCP三次握手\n第一次握手：建立连接时，客户端发送SYN包到服务端，并进入SYN_SENT状态，等待服务器确认。\nSYN：同步序列编号\n第二次握手：服务器收到SYN包，必须确认客户的SYN包，同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态 \n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入，ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\nUTP四次挥手\n第一次挥手：首先客户端向服务端发送断开请求\n(客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u)\n第二次挥手：服务端向客户端进行回复\n(服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一)\n第三次挥手：服务端向客户端断开请求\n(关闭服务器到客户端的连接，发送一个FIN给客户端)\n第四次挥手：客户端收到消息后进行回复\n(客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭)\n\n## Websocket\n\n1. 是一种在单个TCP连接上进行 全双工通信(又称为双向同时通信，即通信的双方可以同时发送和接收信息的信息交互方式。)的协议。\n2. WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n\n\n## 三种读操作\n\n三种读操作比较\nreadline() 每次读一行,读完一行移至下一行(迭代着读){注: 适用于读大型文件}\nreadline速度是fileinput的3倍左右，每秒3-4万行，**好处是 一行行读 ，不占内存**，适合处理比较大的文件，比如超过内存大小的文件\n\nreadlines() 读取整个文件所有行,保存在一个列表变量中,每行作为一个元素\nreadlines会把文件都读入内存，**速度大大增加**，但是木有这么大内存,那就只能乖乖的用readline\n\nread(size)从文件当前位置起读取size个字节，如果不加size会默认一次性读取整个文件（适用于读取小文件）\n\n\n\n## 数据类型\n\n#### 列表\n\nappend  用于在列表末尾追加新的对象\n\ncount   方法统计某个元素在列表中出现的次数\n\n```python\na = ['aa','bb','cc','aa','aa']\nprint(a.count('aa'))   #the result ： 3\n\n```\n\nextend方法可以在列表的末尾一次性追加另一个序列中的多个值\n\n```python\na = [1,2,3]\nb = [4,5,6]\na.extend(b)   #the result ：[1, 2, 3, 4, 5, 6]\n```\n\n\n\nindex  函数用于从列表中找出某个值第一个匹配项的索引位置\n\n insert  方法用于将对象插入到列表中   结合下标使用\n\npop   方法会移除列表中的一个元素（默认是最后一个），并且返回该元素的值\n\nremove  方法用于移除列表中某个值的第一个匹配项\n\n```python\na = ['aa','bb','cc','aa']\na.remove('aa')     #the result ： ['bb', 'cc', 'aa']\n```\n\nreverse  方法将列表中的元素反向存放\n\nsort  方法用于对列表进行排序\n\nenumrate  和for循环差不多  只是能获取下标的同时还能获取item\n\n```python\nli = [11,22,33]\nfor k,v in enumerate(li, 1):\n    print(k,v)\n#打印结果如下:\n1 11\n2 22\n3 33\n```\n\n#### 元祖\n\n元祖和列表一样、只不过元祖是只读列表\n\n##### *列表和元组常用函数*\n\n```\n　　com(x,y)        比较两个值\n\n　　len(seq)        返回序列的长度\n\n　　list(seq)       把序列转换成列表\n\n　　max(args)       返回序列或者参数集合中得最大值\n\n　　min(args)       返回序列或者参数集合中的最小值\n\n　　reversed(seq)   对序列进行反向迭代\n\n　　sorted(seq)     返回已经排列的包含seq 所有元素的列表\n\n　　tuple(seq)      把序列转换成元组\n```\n\n#### 字符串\n\n使用百分号（%）字符串格式化\n\n使用format字符串格式化\n\nfind方法可以在一个较长的字符串中查找子串，他返回子串所在位置的最左端索引，如果没有找到则返回-1\n\n```python\na = 'abcdefghijk'\nprint(a.find('abc'))                 #the result ： 0\nprint(a.find('abc',10,100))          #the result ： 11  指定查找的起始和结束查找位置\n```\n\njoin方法  是非常重要的字符串方法，连接序列中的元素，并且需要被连接的元素都必须是字符串。\n\n```python\na = ['1','2','3']\nprint('+'.join(a))        # 1+2+3\n```\n\nsplit方法  是非常重要的字符串，用来将字符串分割成序列\n\n```python\nprint('1+2+3+4'.split('+'))       # ['1', '2', '3', '4']\n```\n\nstrip 方法返回去除首位空格（不包括内部）的字符串\n\n```python\nprint(\"  test   test   \".strip())       #“test   test”\n```\n\nreplace方法  返回某字符串所有匹配项均被替换之后得到字符串\n\n```python\nprint(\"This is a test\".replace('is','is_test'))        # This_test is_test a test\n```\n\n#### 字典\n\nclear方法清除字典中所有的项，这是一个原地操作，所以无返回值（或则说返回None）\n\n```python\nd = {}\nd['Tom']=8777\nd['Jack']=9999\nprint(d)                                # {'Jack': 9999, 'Tom': 8777}\nd.clear()\nprint(d)                                # {}\n```\n\ncopy方法返回一个具有相同 ”键-值” 对的新字典，而不是副本\n\n```python\nd = {'Tom':8777,'Fly':6666}\na = d.copy()\na['Tom'] = '改变后的值'\nprint(d)                        #{'Fly': 6666, 'Tom': 8777}\nprint(a)                        #{'Fly': 6666, 'Tom': '改变后的值'}\n\n# 查看内存地址\nd={'tom':122,'fly':221}\nid(d)\n1932459885696\n\na=d.copy()\na\n{'tom': 122, 'fly': 221}\nid(a)\n1932488640048\n```\n\nfromkeys方法使用给定的键建立新的字典，每个键都对应一个默认的值None。\n\nget方法是一个访问字典项的方法\n\n for循环字典的三种方法\n\n```python\nd = {'Tom':8777,'Jack':8888,'Fly':6666}\nfor k,v in d.items():\n    print(k,v)\nfor k in d.values():\n    print(k)\nfor k in d.keys():\n    print(k)\n```\n\npop方法 用于获得对应与给定键的值，然后将这个”键-值”对从字典中移除\n\nupdate方法可以利用一个字典项更新另一个字典，提供的字典中的项会被添加到旧的字典中\n\n```python\n>>> a\n{'tom': 122, 'fly': 221}\n>>> b={'age':20}\n>>> a.update(b)\n>>> a\n{'tom': 122, 'fly': 221, 'age': 20}\n```\n\n##### 将两个列表组合成字典\n\n```python\nkeys = ['a', 'b']\nvalues = [1, 2]\n\n#1、zip生成字典\nprint(dict(zip(keys,values)))                        # {'a': 1, 'b': 2}\n#2、for循环推倒字典\nprint({keys[i]: values[i] for i in range(len(keys))})       # {'a': 1, 'b': 2}\n```\n\n#### 集合\n\n```python\nlist_1 = [1,2,3,4,5,1,2]\n#1、去重(去除list_1中重复元素1,2)\nlist_1 = set(list_1)                                    #去重： {1, 2, 3, 4, 5}\nprint(list_1)\nlist_2 = set([4,5,6,7,8])\n\n#2、交集（在list_1和list_2中都有的元素4,5）\nprint(list_1.intersection(list_2))                      #交集： {4, 5}\n\n#3、并集（在list_1和list_2中的元素全部打印出来，重复元素仅打印一次）\nprint(list_1.union(list_2))                             #并集： {1, 2, 3, 4, 5, 6, 7, 8}\n\n#4、差集\nprint(list_1.difference(list_2))                        #差集：在list_1中有在list_2中没有：   {1, 2, 3}\nprint(list_2.difference(list_1))                        #差集：在list_1中有在list_2中没有：   {8, 6, 7}\n\n#5、子集\nprint(list_1.issubset(list_2))                          #子集：    False    List_1中的元素是否全部在list2中\n#6、父集\nprint(list_1.issuperset(list_2))                        #父集：    False    List_1中是否包含list_2中的所有元素\n\n#7、交集\nprint(list_1 & list_2)                                  #交集    {4, 5}\n\n#8、union并集\nprint(list_1 | list_2)                                  #并集：  {1, 2, 3, 4, 5, 6, 7, 8}\n\n#9、difference差集\nprint(list_1 - list_2)                                  #差集：    {1, 2, 3}\n\n#10、在集合中添加一个元素999\nlist_1.add(999)\nprint(list_1)                                           #Add()方法：          {1, 2, 3, 4, 5, 999}\n\n#11、删除集合中任意一个元素不会打印删除的值\nlist_1.pop()                                            #Pop()方法：     无返回值\n\n#12、discard删除集合中的指定元素，如过没有则返回None\nprint(list_1.discard(\"ddd\"))                            #Discard()方法：   删除指定的值，没有返回None\n```\n\n\n\n## 数据结构\n\n### 栈\n\n#### 栈的定义\n\n栈是一种数据集合，可以理解为只能在一端进行插入或删除操作的列表 \n\n#### 栈的特点\n\n  后进先出      栈有栈顶和栈底\n\n#### 栈的基本操作\n\n进栈（压栈）：push\n\n出栈：pop\n\n取栈顶：gettop\n\n#### 栈的应用场景\n\n匹配括号是否成对出现\n\n```python\ndef check_kuohao(s):\n   stack = []\n   for char in s:\n      if char in ['(','[','{']:\n         stack.append(char)\n      elif char == ')':\n         if len(stack)>0 and stack[-1] == '(':\n            stack.pop()\n         else:\n            return False\n      elif char == ']':\n         if len(stack) > 0 and stack[-1] == '[':\n            stack.pop()\n         else:\n            return False\n      elif char == '}':\n         if len(stack) > 0 and stack[-1] == '{':\n            stack.pop()\n         else:\n            return False\n   if len(stack) == 0:\n      return True\n   else:\n      return False\nprint(check_kuohao('(){}{}[]'))  #True\n```\n\n### 队列\n\n#### 队列的定义\n\n1. 队列是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除\n2. 插入的一端称为队尾（rear），插入动作叫进队或入队\n3. 进行删除的一端称为对头（front），删除动作称为出队\n4. 队列性质：先进先出（First-in, First-out）\n5. 双向队列：队列的两端都允许进行进队和出队操作\n\n#### 队列的使用方法\n\n1. 导入： from collectios import deque\n2. 创建队列：queue = deque(li)\n3. 进队： append\n4. 出队： popleft\n5. 双向队列队首进队：appendleft\n6. 双向队列队尾出队：pop\n\n### 链表\n\n#### 单链表\n\n链表中每个元素都是一个对象，每个对象称为一个节点，包含有数据域key和指向下一节点的指针next，通过各个节点间的相互连接，最终串联成一个链表\n\n![img](https://img2018.cnblogs.com/blog/1080958/201902/1080958-20190216100525689-2146864694.png)\n\n单链表第一个节点没有前驱，最后一个节点没有后继。\n\n##### 链表反转\n\n```python\nclass Node(object):\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\ndef list_reverse(head):\n    if head == None:\n        return None\n    L, R, cur = None, None, head  # 左指针、有指针、游标\n    while cur.next != None:\n        L = R             # 左侧指针指向以前右侧指针位置\n        R = cur           # 右侧指针前进一位指向当前游标位置\n        cur = cur.next    # 游标每次向前进一位\n        R.next = L        # 右侧指针指向左侧实现反转\n    cur.next = R          # 当跳出 while 循环时 cur(原链表最后一个元素) R(原链表倒数第二个元素)\n    return cur\n\nif __name__ == '__main__':\n    '''\n    原始链表：1 -> 2 -> 3 -> 4\n    反转链表：4 -> 3 -> 2 -> 1\n    '''\n    l1 = Node(1)\n    l1.next = Node(2)\n    l1.next.next = Node(3)\n    l1.next.next.next = Node(4)\n    l = list_reverse(l1)\n    print l.val         # 4  反转后链表第一个值4\n    print l.next.val    # 3  第二个值3\n```\n\n#### 双链表\n\n双链表中每个节点有两个指针：一个指针指向后面节点、一个指向前面节点\n\n![img](https://img2018.cnblogs.com/blog/1080958/201902/1080958-20190216100633758-1407524935.png)\n\n\n\n#### 单向循环链表\n\n本质和单向联链表一样,但循环链表的最后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。\n\n\n\n#### 数组\n\n数组的定义\n\n1. 所谓数组，就是相同数据类型的元素按一定顺序排列的集合\n2. 在Java等其他语言中并不是所有的数据都能存储到数组中，只有相同类型的数据才可以一起存储到数组中。\n3. 因为数组在存储数据时是按顺序存储的，存储数据的内存也是连续的，所以他的特点就是寻址读取数据比较容易，插入和删除比较困难。\n\n##### python中list与数组比较\n\n1. python中的list是python的内置数据类型，list中的数据类不必相同的，而array的中的类型必须全部相同。\n2. 在list中的数据类型保存的是数据的存放的地址，简单的说就是指针，并非数据\n3. 这样保存一个list就太麻烦了，例如list1=[1,2,3,'a']需要4个指针和四个数据，增加了存储和消耗cpu。\n\n\n\n#### 字典实现原理\n\n##### 哈希表\n\n1. 哈希表（也叫散列表），根据关键值对(Key-value)而直接进行访问的数据结构。\n\n   它通过把key和value映射到表中一个位置来访问记录，这种查询速度非常快，更新也快。\n\n1. 而这个映射函数叫做哈希函数，存放值的数组叫做哈希表\n\n\n\n## Python常用模块\n\n\n\n#### subprocess\n\n###### **subprocess原理**\n\n1. 运行python的时候，我们都是在创建并运行一个进程。像Linux进程那样，一个进程可以fork一个子进程，并让这个子进程exec另外一个程序\n2. 在Python中，我们通过标准库中的subprocess包来fork一个子进程，并运行一个外部的程序。\n3. subprocess包中定义有数个创建子进程的函数，这些函数分别以不同的方式创建子进程，所以我们可以根据需要来从中选取一个使用\n4. 另外subprocess还提供了一些管理标准流(standard stream)和管道(pipe)的工具，从而在进程间使用文本通信。\n\n\n\n###### **subprocess.Popen()`**\n\n​\tPopen对象创建后，主程序不会自动等待子进程完成。我们必须调用对象的wait()方法，父进程才会等待 (也就是阻塞block)\n\n###### **subprocess.PIPE **\n\n将多个子进程的输入和输出连接在一起\n\nsubprocess.PIPE实际上为文本流提供一个缓存区。child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走\n\n#### paramiko\n\n###### **Paramiko模块作用**\n\n1. 如果需要使用SSH从一个平台连接到另外一个平台，进行一系列的操作时，\n\n​    比如：批量执行命令，批量上传文件等操作，paramiko是最佳工具之一。\n\n1. paramiko是用python语言写的一个模块,遵循SSH2协议,支持以加密和认证的方式，进行远程服务器的连接\n2. 支持多平台 如Linux, Solaris, BSD,MacOS X, Windows等\n\n#### re\n\n###### 常用正则表达式符号\n\n通配符  ●\n\n　　　　　　**作用：**● 可以匹配除换行符以外的任意一个字符串\n\n转义字符  ╲\n\n　　　　　　**作用：**可以将其他有特殊意义的字符串以原本意思表示\n\n　　　　　　**注：**如果想对反斜线（\\）自身转义可以使用双反斜线（\\\\\\）这样就表示’\\’\n\n**字符集**\n\n　　　　　　**作用：**使用中括号来括住字符串来创建字符集，字符集可匹配他包括的任意字串\n\n　　　　　　　　**①**‘[pj]ython’ 只能够匹配‘python’  ‘jython’\n\n　　　　　　　　**②**  [a-z] 能够（按字母顺序）匹配a-z任意一个字符\n\n　　　　　　　　**③**  [a-zA-Z0-9] 能匹配任意一个大小写字母和数字    \n\n　　　　　　　　**④** [ ^abc ] 可以匹配任意除a,b和c 之外的字符串\n\n**管道符**\n\n　　　　　　**作用：**一次性匹配多个字符串\n\n　　　　　　**例如：**’python | perl’ 可以匹配字符串‘python’ 和 ‘perl’\n\n\n\n**.最常用的匹配方法**\n\n　　　　　　    \\d     匹配任何十进制数；它相当于类 [0-9]。\n　　　　　　    \\D     匹配任何非数字字符；它相当于类 [  ^0-9  ]。\n　　　　　　    \\s     匹配任何空白字符；它相当于类 [ fv]。\n　　　　　　    \\S     匹配任何非空白字符；它相当于类 [ ^ fv ]。\n　　　　　　    \\w     匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。\n　　　　　　    \\W     匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]。\n\n　　　　　　    \\w*    匹配所有字母字符\n\n　　　　　　    \\w+    至少匹配一个字符\n\n###### 匹配时忽略大小写\n\n```python\nimport re\n#匹配时忽略大小写\nprint(re.search(\"[a-z]+\",\"abcdA\").group())                #abcd\nprint(re.search(\"[a-z]+\",\"abcdA\",flags=re.I).group())     #abcdA\n```\n\n#### sys\n\n###### **sys基本方法**\n\n　　　　sys.argv　　　　　　　　　　返回执行脚本传入的参数\n\n　　　　sys.exit(n)        　　　　           退出程序，正常退出时exit(0)\n\n　　　　sys.version        　　                 获取Python解释程序的版本信息\n\n　　　　sys.maxint         　　                 最大的Int值\n\n　　　　sys.path          　　                    返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值\n\n　　　　sys.platform       　　                  返回操作系统平台名称\n\n#### os\n\nos模块就是对操作系统进行操作\n\n```python\nimport os\n# 当前工作目录，即当前python脚本工作的目录路径\nprint(os.getcwd())    # C:\\Users\\admin\\PycharmProjects\\s14\\Day5\\test4\n\n# 当前脚本工作目录；相当于shell下cd\nos.chdir(\"C:\\\\Users\\\\admin\\\\PycharmProjects\\\\s14\")\nos.chdir(r\"C:\\Users\\admin\\PycharmProjects\\s14\")\nprint(os.getcwd())    # C:\\Users\\admin\\PycharmProjects\\s14\n\n# 返回当前目录: ('.')\nprint(os.curdir)        # ('.')\n\n#4 获取当前目录的父目录字符串名：('..')\nprint(os.pardir)        # ('..')\n\n# 可生成多层递归目录\nos.makedirs(r'C:\\aaa\\bbb')         # 可以发现在C盘创建了文件夹/aaa/bbb\n\n# 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推\nos.removedirs(r'C:\\aaa\\bbb')    # 删除所有空目录\n\n\n# 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname\nos.rmdir(r'C:\\aaa')        # 仅删除指定的一个空目录\n\n# 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印\nprint(os.listdir(r\"C:\\Users\\admin\\PycharmProjects\\s14\"))\n\n# 删除一个文件\nos.remove(r'C:\\bbb\\test.txt')        # 指定删除test.txt文件\n\n# 重命名文件/目录\nos.rename(r'C:\\bbb\\test.txt',r'C:\\bbb\\test00.bak')\n\n# 获取文件/目录信息\nprint(os.stat(r'C:\\bbb\\test.txt'))\n\n# 运行shell命令，直接显示\nos.system(\"bash command\")\n\n# 获取系统环境变量\nprint(os.environ)                # environ({'OS': 'Windows_NT', 'PUBLIC': ………….\n\n# 返回path规范化的绝对路径\nprint(os.path.abspath(r'C:/bbb/test.txt'))    # C:\\bbb\\test.txt\n\n# 将path分割成目录和文件名二元组返回\nprint(os.path.split(r'C:/bbb/ccc'))    # ('C:/bbb', 'ccc')\n\n# 无论linux还是windows，拼接出文件路径\nput_filename = '%s%s%s'%(self.home,os. path.sep, filename)\n#C:\\Users\\admin\\PycharmProjects\\s14\\day10select版FTP\\home\n```\n\n\n\n#### time\n\n###### **time()模块中的重要函数**\n\n| **函数**          | **描述**                                 |\n| ----------------- | ---------------------------------------- |\n| asctime([tuple])  | **将时间元组转换为字符串**               |\n| localtime([secs]) | **将秒数转换为日期元组（转换成本国时区** |\n| mktime(tuple)     | **将时间元组转换为本地时间**             |\n| time()            | **获取当前时间戳**                       |\n|                   |                                          |\n\n###### **time()模块时间转换**\n\n1. 时间戳               1970年1月1日之后的秒，     即：time.time()\n2. 格式化的字符串    2014-11-11 11:11，           即：time.strftime('%Y-%m-%d')\n3. 结构化时间          元组包含了：年、日、星期等... time.struct_time    即：time.localtime()\n\n#### datetime\n\n```python\nimport datetime\n#1、datetime.datetime获取当前时间\nprint(datetime.datetime.now())\n#2、获取三天后的时间\nprint(datetime.datetime.now()+datetime.timedelta(+3))\n#3、获取三天前的时间\nprint(datetime.datetime.now()+datetime.timedelta(-3))\n#4、获取三个小时后的时间\nprint(datetime.datetime.now()+datetime.timedelta(hours=3))\n#5、获取三分钟以前的时间\nprint(datetime.datetime.now()+datetime.timedelta(minutes = -3))\n\nimport datetime\nprint(datetime.datetime.now())                                   #2017-08-18 11:25:52.618873\nprint(datetime.datetime.now().date())                            #2017-08-18\nprint(datetime.datetime.now().strftime(\"%Y-%m-%d %H-%M-%S\"))    #2017-08-18 11-25-52\n\n时间戳转换成datetime对象\n# datetime.datetime.fromtimestamp(1520561646.8906238)\ndatetime.datetime(2018, 3, 9, 10, 14, 6, 890624)\n```\n\n\n\n","tags":["python"]},{"title":"linux","url":"/dp.github.io/2016/04/17/linux-root/","content":"\n##### Root 用户破解流程\n\n> 1. e ; 进入 VMware 页面 按 e 进入编辑模式。\n> 2. rd.break ; 在quiet后加入 rd.break。\n> 3. ctrl + x; 按 ctrl + x 进入 swtch_root 模式。\n> 4. mout -o remount,rw /sysroot ; 重新挂载分区。\n> 5. chroot /sysroot ; 切换根分区。\n> 6. passwd root ; 修改root密码，必须是8位以上复杂密码。\n> 7. touch /.autorelabel ; selinux 在重启后更新label。\n> 8. exit ； 退出。\n> 9. reboot ； 重启\n\n#####  Selinux、Firewalld和Iptables基础设置\n\n> **Selinux防火墙:**\n>\n> 1. 查看  sestatus \n> \t. 关闭  vi /etc/selinux/config \t  修改 SELINUX=disabled\n> 3. 重启  init 6\n>\n> \n>\n> **firewalld防火墙:**\n>\n> 1. 查看  systemctl status firewalld\n>\n> 2. 关闭   systemctl stop firewalld\n>\n> 3. 开机关闭   systemctl disabled firewalld\n>\n>    \n>\n> **iptables防火墙:**\n>\n> 1. 查看规则   iptables -L -n\n>\n> 2. 清空规则  iptables -F\n>\n> 3. 保存规则  service iptables save\n>\n>\n> 如果`iptables`防火墙不能通过`save`保存规则，解决如下：\n\n```shell\nyum软件包安装[centOS8]:\n\n1. 挂载光盘\nmount /dev/cdrom /media\n\n2.查看挂载\ndf\n\n3.配置yum\ncd /etc/yum.repos.d/\nmv CentOS-Media.repo /mnt\nrm -rf *\nmv /mnt/CentOS-Media.repo ./\n\n4.vi CentOS-Media.repo 修改文件\n[c8-media-BaseOS]\nbaseurl=file:///media/BaseOS\ngpgcheck=0\nenabled=1\n\n[c8-media-AppStream]\nbaseurl=file:///media/AppStream\ngpgcheck=0\nenabled=1\n\n5.查看yum可控制的软件包\nyum list | wc -l  \nyum list | grep iptables\n\n6.yum安装rpm软件包\nyum -y install iptables-service\n```\n\n\n\n\n\n##### 网络管理\n\n```shell \nBOOTPROTO=dhcp | static  # 修改为静态\nONBOOT=yes | no   # 开机自启动\nIPADDR=192.168.1.100  \nNETMASK=255.255.255.0\nGATEWAY=192.168.1.1\nDNS1=114.114.114.114\nDNS1=8.8.8.8\n```\n\n\n\n##### Linux 系统目录结构\n\n>  / ：根目录，相当于中央系统      /home ：家目录，普通用户存放文件             /root ：超级用户                            \n>\n>  /bin ：普通用户可以使用命令的存放目录      /sbin ：超级用户可以使用命令的存放目录\n>\n>  /boot ：引导 程序、内核等存放的目录           /dev ： 设备文件存储目录      /etc ：全局配置文件存放目录\n>\n>  /lib ：根目录下所有程序的共享目录（32位）               /lib64：根目录下所有程序的共享目录（64位）\n>\n>  /media：挂载媒体设备目录                       /mnt：临时挂载文件目录\n>\n>  /opt：程序存放目录                                /proc：特殊文件目录                  /srv ： 服务创建目录\n>\n>  /sys ： 硬件设备的驱动程序信息                       /var ： 存放内容经常变化目录            /tmp ： 临时文件目录\n>\n\n\n\n##### 系统命令\n\n```shell\n查看内存:\nfree \nfree -m\nfree -g\n\n查看硬盘:\ndf \ndf -T\ndf -h\n\n查看系统正在登录的用户:\nwho\n\n查看系统最后一重要操作:\nlast\n\n查看进程实时消耗的cpu和内存:\ntop\n\n查看系统1分钟、5分钟和15分钟平均负载:\nuptime\n\n查看服务进程:\nps -ef \npstree\n\n查看服务端口:\nnetstat -tunpl \n\n杀掉进程:\nkill -9 pid\npkill pname\n```\n\n","tags":["Linux"],"categories":["Linux"]},{"title":"汽车之家图片爬取","url":"/dp.github.io/2016/03/27/qctp/","content":"\n**爬虫类爬取网站图片，并保存到文件夹**\n\n```python\n# 汽车之家图片爬取\nimport time\nimport os\nimport urllib.request\nfrom bs4 import BeautifulSoup\nfrom multiprocessing  import Pool\n\n\n# 获取汽车图片方法类\nclass ReTbmm(object):\n\n    def Retbmm(self):\n        # 爬虫开始时间\n        start = time.time()\n        # 用于返回当前工作目录\n        self.cdir = os.getcwd()\n        # 爬起网址 https://car.autohome.com.cn/pic/series/5349.html#pvareaid=2042194\n        # 车身外观\n        url1 = 'https://car.autohome.com.cn/pic/series/5349-1.html#pvareaid=2042220'\n\n        # 中控方向盘\n        url2 = 'https://car.autohome.com.cn/pic/series/5349-10.html#pvareaid=2042220'\n\n        # 车厢座椅\n        url3 = 'https://car.autohome.com.cn/pic/series/5349-3.html#pvareaid=2042220'\n\n        # 其他细节\n        url4 = 'https://car.autohome.com.cn/pic/series/5349-12.html#pvareaid=2042220'\n\n        self.getImg('车身外观',url1)\n        self.getImg('中控方向盘',url2)\n        self.getImg('车厢座椅',url3)\n        self.getImg('其他细节',url4)\n        end = time.time()\n        print('run time',str(end - start))\n\n    # 下载图片方法\n    def getImg(self,name,url):\n        user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' \\\n                     '(KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36'\n        headers = {'User-Agent':user_agent}\n        # 访问连接\n        request = urllib.request.Request(url,headers=headers)\n        # 获取数据\n        response = urllib.request.urlopen(request)\n        # 解析数据\n        bsobj = BeautifulSoup(response,'html.parser')\n        # 获取所有img标签\n        t1 = bsobj.find_all('img')\n\n        path = self.cdir + '\\\\mrsoft\\\\' + str(name)\n\n        if not os.path.exists(path):\n            os.mkdir(path)\n        n = 0\n        for img in t1:\n            n = n + 1\n            link = img.get('src')\n\n            if link :\n                # 图片连接\n                s = 'https:' + str(link)\n\n                i = link[link.rfind('.'):]\n                try:\n                    req = urllib.request.Request(s)\n                    res = urllib.request.urlopen(req)\n                    imgData = res.read()\n                    pathfile = path + r'\\\\' +str(n) + i\n\n                    with open(pathfile,'wb')as f:\n                        f.write(imgData)\n                        f.close()\n                except:\n                    print(str(name)+'thread write false'+ s)\n\nif __name__ == '__main__':\n    r = ReTbmm()\n    pool = Pool(4)\n    for i in range(1,10):\n        pool.apply_async(func=r.Retbmm)\n    pool.close()\n    pool.join()\n\n\n\n```\n\n","tags":["爬虫"],"categories":["python"]},{"title":"面向对象","url":"/dp.github.io/2016/03/22/oo/","content":"\n##### 封装、继承、多态\n\n1. 封装\n   1. 对数据处理时，可以快速定位到需要的方法，修改时更方便。\n   2. 全局变量是只能由1份的，多个函数需要多个备份时，需要利用其他变量来进行存储；通过封装会将用来存储数据的这个变量 变成对象中的一个'全局'变量，只要对象不一样那么这个变量就可以再有一份。\n   3. 代码划分更清晰。\n2. 继承\n   1. 能提升代码的重用率，开发一个类，可以在多个功能中直接使用。\n   2. 继承能够有效的进行代码管理，当某个类有问题只要修改这个类就行，而其继承这个类的子类往往是不需要修改。\n3. 多态\n   1. 不同子类对象调用相同的父类方法，产生不同执行结果。\n   2. 多态可以增加代码的灵活度，以继承和重写父类方法为前提。\n   3. 是调用方法的技巧，不会影响到类的内部设计。\n\n\n\n##### 多继承以及MRO顺序\n\n1. **super().____init____**相对于类名.____init____,在单继承上用法基本无差。\n2. 但在多继承上有区别，super方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次。\n3. 多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否者报错。\n4. 单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则报错。\n5. 多继承时，相对于使用类名.____init____方法，要把每个父类全部写一遍，而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的原因。\n\n\n\n------\n\n在python中，类变量在内部是作为字典处理的。如果一个变量的名字没有在当前类的字典中发现，将搜索父类直到被引用的变量名找到（如果这个引用的变量名即没有在自己所在的类有没有在父类中找到，会引发一个 AttributeError异常）。\n\n------\n\n\n\n##### 实例方法、静态方法、类方法\n\n1. **类属性、实例属性**\n\n*它们定义和使用中都有所区别，而最本质区别是内存中保存的位置不同。*\n\n> - 实例属性属于对象\n> - 类属性属于类\n> - 类属性在内存中只保存一份。\n> - 实例属性在每个对象中都要保存一份。\n\n2. **实例方法、静态方法、类方法**\n\n*方法包括：实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。* \n\n> - 实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self；\n> - 类方法：由类调用或对象调用；至少一个cls参数（默认是cls）；执行类方法时，自动将调用该方法的类赋值给cls；应用场景：当一个方法中只涉及到静态属性的时候可以使用类方法(类方法用来修改类属性) \n> - 静态方法：由类调用或对象调用；无默认参数；应用场景：一般用于和类对象以及实例对象无关的代码。 \n\n3. **对比**\n   - 相同点：对于所有方法而言，均属于类，所以在内存中也只保留一份。\n   - 不同点：方法调用不同，调用方法传参也不同。\n\n\n\n##### python property属性\n\n> - Python的property属性的功能是：property属性内部进行一系列的逻辑计算，最终将计算结果返回。 \n> - 定义property属性共有两种方式，分别是【装饰器】和【类属性】，而【装饰器】方式针对经典类和新式类又有所不同。 \n> -  通过使用property属性，能够简化获取数据的流程 ","tags":["python"],"categories":["python"]}]