[{"title":"常用的 GUI 框架","url":"/dp.github.io/2019/12/18/my-first-one/","content":"##### 什么是 GUI\n\n  GUI是 Graphilcal User Interface（图形用户界面）的缩写。在GUI中，并不只是输入文本和返回文本，用户可以看待窗口、按钮、\n  文本框等图形，而且可以用鼠标单击，还可以通过键盘输入。GUI 是与程序交互的一种不同的方式。GUI 的程序由三个基本要素：输入、处理和输出。\n\n##### 常用的GUI框架\n\n  工具包        |                 描述\n  wxpython  |        wxpython是python语言的一套优秀的GUI图形库，允许python程序员方便创建完整的、功能\t\t\t\t\t\t       \t\t\t\t\t  -                               健全的GUI用户界面。\n  Kivy        |        Kivy是一个开源工具包，可以跨平台使用，主要关注创新型用户界面开发，如多点触摸应用程序。\n  Flexx      |        Flexx是纯python工具包，用来创建图形化界面应用程序。使用web技术进行页面渲染。\n  PyQt       |        PyQt是Qt库的python版本，支持跨平台。\n  Tkinter           Tkinter（也叫做Tk接口）是标准的python接口，Tk是一个轻量级的跨平台图形用户界面开发工具。\n  pywin32 |        Windows pywin32允许用户像VC一样的形式来使用python开发win32 应用。\n  PyGTK   |        PyGTK让用户用python轻松创建具有图形用户界面的程序。\n  pyui4win  |        pyui4win是一个开源的采用自绘技术的界面库。\n\n\n\n","tags":["GUI"],"categories":["GUI(图形用户界面)"]},{"title":"python 解释器","url":"/dp.github.io/2019/03/27/p-jsq/","content":"\n> 当我们编写python代码时，我们得到的是一个包含python代码的以`.py`为扩展名的文本文件。要运行代码，就需要python解释器去执行`.py`文件。\n\n\n\n##### CPython\n\n> 当我们从python官网下载并安装好python版本后，我们就直接获得了一个官方版本的解释器：Cpython。这个解释器是用C语言开发的，所以叫Cpython。在命令行运行`python`就是启动了CPython解释器。\n\n\n\n##### IPython\n\n> IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。\n>\n> CPython用`>>>`作为提示符，而IPython用`In [序号]:`作为提示符。\n\n\n\n##### PyPy\n\n> PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用 [JIT技术]，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。\n>\n> 绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解[PyPy和CPython的不同点]。\n\n\n\n##### Jyhon\n\n> Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行 。\n\n\n\n##### IronPython\n\n> IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。 ","tags":["python"],"categories":["python"]},{"title":"json 模块","url":"/dp.github.io/2018/03/28/join/","content":"\n##### json 模块\n\n------\n\n**json**是一种轻量级的数据交换格式，python3.x 可以使用json模块来对**json**数据进行编解码。\n\n------\n\n- **json模块的常用方法**\n  - json.dump()\n    - 将**python**数据对象以 **JSON** 格式数据流的形式写入到文件。\n  - json.load()\n    - 解析包含 **JSON** 数据的文件为python对象。\n  - json.dumps()\n    - 将 **python** 数据对象转换为 **JSON** 格式的字符串。\n  - json.loads()\n    - 将包含**JSON**的字符串、字节以及字节数组解析为**python**对象。","tags":["python"],"categories":["python"]},{"title":"网络爬虫分类详解","url":"/dp.github.io/2018/03/17/pac1/","content":"\n##### 爬虫分类\n\n1.通用网络爬虫；\n        通用网络爬虫又叫做全网爬虫，通用网络爬虫的爬取范围和数量巨大，正由于其爬取的数据是海量数据，\n        所以对于爬取速度和存储空间要求较高。通用网络在爬行页面的顺序要求上相对较低，同时由于待刷新的\n        页面太多，通常采用并行工作方式，所以需要较长时间才可以刷新一次页面，所以存在一定的缺陷，这种\n        网络爬虫主要应用于大型搜索引擎中，又非常高应用价值。通用网络爬虫主要由初始URL集合、URL队列、\n        页面爬取模块、页面分析模块、页面数据库、链接过滤模块等构成。\n\n2.聚焦网络爬虫；\n        聚焦网络爬虫也叫做主题网络爬虫，是指按照预定好的主题，有选择地进行相关网页爬取。他和通用\n        网络爬虫相比，不会将目标资源定位在整个互联网当中，而是将爬取目标网页定位在相关的页面中。这\n        样极大地节省了硬件和网络资源，保存的页面也由于数量少而更快了，聚焦网络爬虫主要应用在对特定\n        信息爬取，为某一特定人群提供服务。\n3.增量式网络爬虫；\n        增量式网络爬虫，所谓增量式，对应着增量式更新。增量式更新指的是在更新的时候只更新改变的地方，\n        而未改变的地方则不更新，所以增量式网络爬虫，在爬取网页的时候，只会在需要的时候爬区新产生或跟\n        新的页面，对于没有更新的页面，则不会爬取。这样可有效减少数据下载量，减少时间和空间上的消费，\n        但是再爬行算法上需要增加一些难度。\n4.深层网络爬虫；\n        web页面按存在方式可以分为表层网页和深层网页，表层网页指的是不需要提交表单，使用静态的超链\t接，\n        就可以直接访问静态页面。深层网页指的是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后面\n        的，需要用户提交一些关键词才能获得的web页面。深层页面需要访问的信息数量是表层页面信息数量的几\n        百倍，所以深层页面是主要的爬取对象。\n\n##### 网络爬虫的基本原理：\n\n- [ ] 网络爬虫的基本工作流程；\n\n​    （1）获取初始的URL，该URL地址使用户自己制定的初始爬取的网页。\n    （2）爬取对应的URL地址的网页时，获取新的URL地址。\n    （3）将新的URL地址放入URL队列中。\n    （4）从URL对列中读取新的URL，然后根据新的URL爬取网页，同时从新的网页中获取新的URL地址，重复上\t\t\t 述爬虫过程。\n    （5）设置停止条件，如果没有设置停止条件爬虫会一直爬取直到无法获取新的URL。\n\n##### python网络请求：\n\n在python中实现HTTP网络请求常见三种方式：urllib、urlliib3、requests。\n\n###### **urllib 模块**\n\n​        urllib是python自带模块，该模块提供了一个urlopen()方法，通过该方法指定URL发送网络请求来获取数据。\n        urllib提供了多个子模块具体如下：\n\n​        模块名称            |                 描述\n        urllib.request   |   该模块定义了打开URL（主要是HTTP）的方法和类。例如身份验证、重定向、cookie等。\n        urllib.error        |   该模块主要包含异常类，基本的异常类是URLError。\n        urllib.parse       |   该模块定义的功能分为两大类：URL解析和URL引用。\n        urllib.robotparser | 该模块用于解析robots.txt 文件。\n\n网络请求示例:\n\n\n```python\n# 示例一\nimport urllib.request\n# 打开指定需要爬取的网页\nresponse = urllib.request.urlopen('http://httpbin.org/get')\nhtml = response.read()  # 读取网页代码\nprint(html)             # 打印读取内容\n```\n\n```python\n# 示例二\nimport urllib.request\nimport urllib.parse\n# 将数据使用urlencode编码处理后，在使用encoding设置为utf-8编码\ndata = bytes(urllib.parse.urlencode({'word':'hello'}),encoding='utf-8')\n# 打开指定需要爬取的网页\nresponse = urllib.request.urlopen('http://httpbin.org/post',data=data)\nhtml = response.read()  # 读取网页代码\nprint(html)             # 打印读取内容\n```\n上面示例中，示例一是通过get请求方式获取网页内容，示例二是通过post请求方式获取网页内容。\n\n\n\n###### **urllib3 模块**\n\nurllib3是一个功能强大、条理清晰、用于HTTP客户端的python库，许多python的原生系统已经开始使用urllib3。\n**urllib3 提供了很多python标准库里所没有的重要特性：**\n （1）线程安全。\n （2）连接池。\n （3）客户端SSL/TTS验证。\n （4）使用多部分编码上传文件。\n （5）Helpers 用于重试请求并处理HTTP重定向。\n （6）支持gzip和deflate编码。\n （7） 支持HTTP和SOCKS代理。\n （8）100% 的测试覆盖率。\n\n网络请求示例:\n\n\n```python\nimport urllib3\n\n# 创建 poolManager对象，用于处理于线程池的连接以及线程安全的所有细节。\nhttp = urllib3.poolManager()\n# 对需要爬取的网页发送请求  get/post\nresponse = http.request('GET','http://httpbin.org/')\n# response = http.request('POST','http://httpbin.org/',fields={'word':'hello'})\nprint(response.data)    # 打印读取内容\n```\n\n###### **requests 模块**\n\nrequests 是第三方模块，该模块在实现HTTP请求时要比urllib 模块简单化很多，操作人性化。\n\n​    **requests 功能特性如下:**\n\n​    (1)Keep-Alive & 连接池            (2)Unicode 响应体\n\n​    (3)国际化域名和URL                 (4)HTTP(S)代理支持\n\n​    (5)带持久Cookie 的会话           (6)文件分块上传\n\n​    (7)浏览器式的SSL认证              (8)流下载\n\n​    (9)自动内容解码                        (10)连接超时\n\n​    (11)基本/摘要式的身份验证            (12)分块请求\n\n   (13)key/value Cookie              (14)支持.netrc\n\n   (15)自动解压\n\n以GET请求为例，打印多种请求信息:\n\n ```python \nimport requests\n\nresponse = requests.get('https://www.baidu.com')\nprint(response.status_code)   # 打印状态码\nprint(response.url)   # 打印请求url\nprint(response.headers)   # 打印头部信息\nprint(response.cookies)   # 打印cookie信息\nprint(respomse.text)   # 以文本形式打印网页源码\nprint(response.content)   # 以字节流形式打印网页源码\n\n以post请求，发送http网络请求:\nimport requests\ndata = {'word':'hello'}\nresponse = requests.post('https://www.baidu.com',data=data)\nprint(response.content)\n ```\n\n**requests 模块不及提供了以上两种，还有多种方式:**\n\n​    (1) requests.put()     \n\n​    (2) requests.delete()  \n\n​    (3) requests.head()  \n\n​    (4) requests.options()\n\n**requests 模块提供了三种常见的网络异常类，示例如下:**\n\n\n```python\n# 导入 requests.exceptions 模块中三个异常类\nfrom requests.exceptions import ReadTimeout, HTTPError, RequestException\nReadTimeout（超时异常） HTTPError（HTTP异常） RequestException（请求异常）\n```\n","tags":["爬虫"],"categories":["python"]},{"title":"使用 python 解析 ppt 文档","url":"/dp.github.io/2018/03/15/jppt/","content":"**模块的重载**：考虑到性能的原因，每个模块只被导入一次,放入字典**sys.module**中，如果你改变了模块的内容，你必须重启程序，**python**不支持重新加载或卸载之前导入的模块，可以使用importlib 模块(python默认编码是ASCII编码，当程序出现非ASCII码时，**python**处理常常出现[UnicodeDecodeError:]错误，此时需要自己设置编码，通常为utf-8)。\n\t\t  \n**具体代码：**\n\n```python\nimport sys,importlib\nimportlib.reload(sys)\nimport time\ntime1=time.time()\nimport os.path\nfrom pdfminer.pdfparser import PDFParser,PDFDocument\nfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter\nfrom pdfminer.converter import PDFPageAggregator\nfrom pdfminer.layout import LTTextBoxHorizontal,LAParams\nfrom pdfminer.pdfinterp import PDFTextExtractionNotAllowed\nresult=[]\nclass CPdf2TxtManager():\n    def __init__(self):\n      '''''\n      Constructor\n      '''\n    def changePdfToText(self, filePath):\n      file = open(path, 'rb') # 以二进制读模式打开\n      #用文件对象来创建一个pdf文档分析器\n      praser = PDFParser(file)\n      # 创建一个PDF文档\n      doc = PDFDocument()\n      # 连接分析器 与文档对象\n      praser.set_document(doc)\n      doc.set_parser(praser)\n      # 提供初始化密码\n      # 如果没有密码 就创建一个空的字符串\n      doc.initialize()\n      # 检测文档是否提供txt转换，不提供就忽略\n      if not doc.is_extractable:\n        raise PDFTextExtractionNotAllowed\n      # 创建PDf 资源管理器 来管理共享资源\n      rsrcmgr = PDFResourceManager()\n      # 创建一个PDF设备对象\n      laparams = LAParams()\n      device = PDFPageAggregator(rsrcmgr, laparams=laparams)\n      # 创建一个PDF解释器对象\n      interpreter = PDFPageInterpreter(rsrcmgr, device)\n      pdfStr = ''\n      # 循环遍历列表，每次处理一个page的内容\n      for page in doc.get_pages(): # doc.get_pages() 获取page列表\n        interpreter.process_page(page)\n        # 接受该页面的LTPage对象\n        layout = device.get_result()\n        for x in layout:\n          if hasattr(x, \"get_text\"):\n            # print x.get_text()\n            result.append(x.get_text())\n            fileNames = os.path.splitext(filePath)\n            results = x.get_text()\n            # print(results)\nif __name__ == '__main__':\n  '''''\n   解析pdf 文本，保存到txt文件中\n  '''\n  path = u'D:\\text\\book\\text.pdf'\n  pdf2TxtManager = CPdf2TxtManager()\n  pdf2TxtManager.changePdfToText(path)\n  time2 = time.time()\n  print(u'ok,解析pdf结束!')\n  print(u'总共耗时：' + str(time2 - time1) + 's')\n```\n\n\n\n\n\n","tags":["python"],"categories":["python"]},{"title":"线程与进程","url":"/dp.github.io/2017/03/17/xjc/","content":"\n#### python\n\n##### 线程与进程的区别：\n\n> 1. 进程是系统进行资源分配和调度的一个单位，线程是进程的一个实体，是cpu调度和分配的基本单位。\n> 2. 进程之间是相互独立的，多进程中，同一个变量，各自有一个备份存在于每个进程中，但互不影响；而同一个进程的多个线程是内存共享的，所有变量都由所有线程共享。\n> 3. 由于进程间是相互独立的，因此一个进程的崩溃不会影响到其他进程；而线程是包含在进程之内的， 线程的崩溃就会引发进程的崩溃，继而导致同一个进程内的其他线程也崩溃。多线程非全局变量是否要加锁；在多线程开发中，全局变量是多个线程都共享的数据，为了防止数据混乱，通常使用互斥锁。而局部变量等是各自线程的，是非共享的，所以不需要使用互斥锁。\n\n\n\n##### 进程：\n\n1. **进程定义**\n\n------\n\n- 进程是资源分配最小单位。\n- 当一个可执行程序被系统执行（分配内存资源）就变一个进程。\n\n------\n\n2. **进程定义拓展**\n\n   \n\n   1. 程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，这种执行的程序就称为进程。\n   2. 程序和进程的区别就在于：程序是指令集合，它是进程运行的静态描述文本；进程是程序一次执行活动，属于动态概念。\n   3. 在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发执行。\n   4. 进程的出现让每个用户感觉自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。\n   5. 进程之间有自己独立的内存，各进程之间不能相互访问。\n\n   \n\n   ------\n\n   \n\n3. **多道编程概念**\n\n   1. 多道编程：在计算机内存中同时存放几道相互独立的程序，它们共享系统资源，相互穿插运行。\n   2. 单道编程：计算机内存中只允许一个程序运行。\n\n4. **进程间访问数据的四种方法**\n\n   注：不同进程间内存是不共享的，所以相互之间不能访问数据。\n\n   1. 利用Queues实现父进程到子进程（或子进程间）的数据传递。\n   2. 使用管道pipe实现两个进程间数据传递。\n   3. Managers实现多进程间数据共享。\n\n5. **进程池**\n\n```python\nfrom multiprocessing import Process . Pool\nimport time, os\n\ndef foo(i):\n    time.sleep(2)\n    print('in the process',os.getpid()) # 打印子进程pid\n    return i + 100\n\ndef call(arg):\n    print('-->exec done:',arg,os.getpid())\n\nif __name__ == '__main__':\n    pool = Pool(3)  # 进程最多允许5个进程放入进程池\n    print('主进程pid:',os.getpid()) # 打印父进程pid\n    for i in range(10):\n        # 用法一，callback作用是指定只有当Foo运行结束后就执行callback调用的函数，父进程调用的\t\t\t\t# callback函数。\n        pool.apply_async(func=foo,args=(i,),callback=call)\n        # 用法二， pool.apply(func=foo,args=(i,))\n        \n\tprint('end')\n    pool.close() # 关闭进程池。\n    pool.join() # 进程池中进程执行完毕后在关闭，如果没有程序直接关闭。\n    \n    \n```\n\n\n\n##### 线程：\n\n1. **线程定义**\n\n------\n\n- 线程是操作系统调度最小单位。\n- 它包含在进程之中，是进程实际运作单位。\n- 进程本身是无法自己执行的，要操作CPU，必须创建一个进程，线程是一系列指令的集合。\n\n------\n\n2. **线程定义拓展**\n\n   1. 线程是操作系统能够进行运算调度最小单位。包含在进程之中，是进程实际运作单位。\n   2. 一个线程是一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程并行执行不同任务。\n   3. 无论启动多少个线程，你有多少个CPU，python在执行时只会在同一时刻运行一个线程。\n   4. 所有在同一个进程里的线程是共享一块内存资源的，不同进程间内存空间不同。同一个进程中的各线程可以相互访问资源，线程可以操作同进程中其它线程，但进程仅能操作子进程。\n   5. 两个进程间通信，必须通过一个中间代理。\n\n   \n\n3. **线程锁**\n\n   ------\n\n   1.  当一个线程对某个资源进行CPU计算的操作时加一个线程锁，只有当前线程计算完成 主动释放锁，其它线程才能操作。\n   2. 这样防止了还未计算完成，释放GIL锁后其它线程对这个资源操作导致混乱问题。\n\n4. **Semaphore（信号量）**\n\n   ------\n\n   1.  互斥锁 同时只允许一个线程更改数据，而 semaphore 是同时允许一定数量的线程更改数据。\n   2. 作用就是同一时刻允许运行的线程数量。\n   3. 比如餐厅由三个座位，那么最多只允许三个人吃饭，后面的人只能等前面的人吃饭完后才能进去吃饭。\n\n5. ****\n\n   **setDaemon(): 守护线程，主线程退出时，需要⼦线程随主线程退出 **\n\n```python\nimport threading\nimport time\nstart_time = time.time()\ndef sayhi(num): #定义每个线程要运行的函数\n\tprint(\"running on number:%s\" %num)\n \ttime.sleep(3)\nfor i in range(50):\n    t = threading.Thread(target=sayhi,args=('t-%s'%i,))\n    t.setDaemon(True) #把当前线程变成守护线程，必须在 t.start()前设置\n    t.start() #启动一个线程，程序不会阻塞\nprint('cost time:',time.time() - start_time)\n```\n\n\n\n6. **线程池实现并发**\n\n\n```python\nimport requests\nfrom concurrent.futures import ThreadPoolExecutor\ndef fetch_request(url):\n \tresult = requests.get(url)\n \tprint(result.text)\nurl_list = [\n 'https://www.baidu.com',\n 'https://www.google.com/', #google 页面会卡住，知道页面超时后这个进程才结束\n 'http://dig.chouti.com/', #chouti 页面内容会直接返回，不会等待 Google 页面的返回\n]\npool = ThreadPoolExecutor(10) # 创建一个线程池，最多开 10 个线程\nfor url in url_list:\n \tpool.submit(fetch_request,url) # 去线程池中获取一个线程，线程去执行 fetch_request 方法\npool.shutdown(True) # 主线程自己关闭，让子线程自己拿任务执行\n```\n\n\n\n##### 协程：\n\n1. **什么是协程**\n   1. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次天调用的状态。\n   2. 协程最主要的作用是 在单线程的条件下实现并发的效果，但实际上还是串行 的（像yield一样）\n\n   \n\n2. **协程缺点（无法利用多核资源）**\n\n   1. 协程本身是个单线程，他不能同时将单个CPU 的多个核 使用，协程需要和进程配合才能运行在多个CPU上，线程阻塞（Blocking）操作会阻塞掉整个程序。\n\n3.  **协程为何能处理⼤并发 1：Greenlet 遇到 I/O ⼿动切换**\n\n   1. 协程之所以快就是因为遇到 I/O 操作就切换（最后只有CPU运算）。\n   2. 其实Gevent模块仅仅是对greenlet的再次封装，将 I/O 间的手动切换变成自动切换。\n\n4. **协程为何能处理⼤并发 2：Gevent 遇到 I/O ⾃动切换** \n\n   1.  Gevent 是⼀个第三⽅库，可以轻松通过 gevent 实现并发同步或异步编程 。\n   2. 在 gevent 中⽤到的主要模式是 Greenlet, 它是以 C 扩展模块形式接⼊ Python 的轻量级协程 。\n   3.  Greenlet 全部运⾏在主程序操作系统进程的内部，但它们被协作式地调度。 \n   4.  Gevent 原理是只要遇到 I/O 操作就会⾃动切换到下⼀个协程 。\n\n5. **使⽤协程处理并发** \n\n   **注：Gevent 只⽤起⼀个线程，当请求发出去后 gevent 就不管,永远就只有⼀个线程⼯作，谁先回来先处理**\n\n   ```python\n   import gevent\n   import requests\n   from gevent import monkey\n   monkey.patch_all()\n   # 这些请求谁先回来就先处理谁\n   def fetch_async(method, url, req_kwargs):\n    \tresponse = requests.request(method=method, url=url, **req_kwargs)\n    \tprint(response.url, response.content)\n   # ##### 发送请求 #####\n   gevent.joinall([\n    gevent.spawn(fetch_async, method='get', url='https://www.python.org/', req_kwargs={}),\n    gevent.spawn(fetch_async, method='get', url='https://www.google.com/', req_kwargs={}),\n    gevent.spawn(fetch_async, method='get', url='https://github.com/', req_kwargs={}),\n   ])\n   ```\n\n   ------\n\n   \n\n##### GIL（全局解释器锁）\n\n**描述Python GIL的概念， 以及它对python多线程的影响？** \n\n**为了解决不同线程同时访问同一资源时，产生了GIL**\n\n**参考：**\n\n> 1. Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。\n> 2. GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。\n> 3. 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100\n> 4. Python使用多进程是可以利用多核的CPU资源的。\n> 5. 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁。\n\n\n\n##### 深拷贝、浅拷贝：\n\n1. **浅拷贝**\n   1. 浅拷贝是对于一个对象的顶层拷贝，拷贝了引用，并没有拷贝内容。 \n\n![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20171023-204000@2x.png)\n\n![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20170420-071018@2x.png)\n\n2. **深拷贝**\n   1. 深拷贝是对于一个对象所有层次的拷贝(递归) \n\n![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20171023-204653@2x.png)\n\n**进一步理解深拷贝**\n\n ![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20171023-205139@2x.png)\n\n![](D:\\mhpboke\\dp.github.io\\hexo\\themes\\hexo-theme-aircloud\\source\\img\\QQ20171023-205202@2x.png)\n\n3. **注意点**\n\n   **浅拷贝对不可变类型和可变类型的copy不同**\n\n   1. copy.copy对于可变类型，会进行浅拷贝 。\n   2. copy.copy对于不可变类型，不会拷贝，仅仅是指向 。\n\n","tags":["python"],"categories":["python"]},{"title":"扫描并输出局域网占用的 IP 地址","url":"/dp.github.io/2017/03/15/mynew2/","content":"**sys.argv[] 指令:** 是一个程序外部来获取参数的，0是指代码本身的路径。可以通过外部来获取多个参数，类似列表。所以使用[]来获取。\n\n\n**argparse** : \n是命令行解析模块；sys.argv[]是通过外部传的参数，无法通过编辑器直接运行，而是通过dos命令行里操作；两者可以结合使用。\n\n\n\n```python\nimport sys,  socket\nimport threading\n\nlist_of_name = []\nlist_of_ip = []\nthread_pool = []\n\ndef showInfo():\n    print(\"\"\"\n        命令格式：LAN_ip_hostname -all startip\n                LAN_ip_hostname -ip ipaddr\n                LAN_ip_hostname -hostname hostname\n        说明：   -all 扫描局域网中所有IP对应的 hostname，需要起始IP，如192.168.0.1\n                -ip 获取指定ip的hostname\n                -hostname 根据主机名，得到ip地址\n    \"\"\")\n\ndef LanAll(startip):\n    index = startip.rfind('.') # 找出最右边 . 的索引\n    ipfirstpart = startip[0:index + 1] # ip 地址中前三位，如 192.168.0.1\n    intstart = int(startip[index + 1])  # ip 地址最后一位，转为int\n    f = range(intstart,255)\n    global g_mutex\n    g_mutex = threading.Lock()  # 初始化互斥锁\n    for iplastpart in f:\n        targetip = ipfirstpart + str(iplastpart) # 拼接ip\n        # 创建线程对象，存为 thread 线程要执行的函数由 target 指定，args 指定参数，\n        # 可以是元组~。线程号从 1 开始\n        thread = threading.Thread(target=Lanlp2Name,args=(targetip,))\n        thread_pool.append(thread)\n        thread.start()\n    # 阻塞主线程 collect all threads\n    for pos in f:\n        threading.Thread.join(thread_pool[pos - intstart])\n    #输出结果\n    hosts = range(0,len(list_of_name))\n    for host in hosts:\n        print(list_of_ip[host],'======>',list_of_name[host])\n    print('Find',len(list_of_name),'hosts.Done!')\ndef Lanlp2Name(ip):\n    try:\n        (name, aliaslist,addresslist) = socket.gethostbyaddr(ip)\n    except:\n        return\n    global g_mutex # 再次声明\n    g_mutex.acquire()  # 上锁\n    list_of_name.append(name)\n    list_of_ip.append(ip)\n    g_mutex.release()  # 释放锁\ndef LanipToName(ip):\n    try:\n        (name, aliaslist,addresslist) = socket.gethostbyaddr(ip)\n    except:\n        return\n    print('%s ======>%s'%(addresslist,name))\ndef LanName2IP(name):\n    targetip = socket.gethostbyname(name)\n    print(name,'=====>',targetip)\nif __name__ == '__main__':\n    if len(sys.argv) < 3:\n        print('参数错误')\n        showInfo()\n        exit(1)\n    cmds = ['-all','-ip','-hostname']\n    cmd = sys.argv[1] # 命令格式\n    target = sys.argv[2] # ip地址\n    if 0 == cmds.count(cmd):\n        print('参数错误啊')\n        showInfo()\n        exit(1)\n    else:\n        print('开始工作请等待...')\n        if cmd == '-all':\n            LanAll(target) # 输出所有的 主机 与 ip 名\n        elif cmd  == '-ip':\n            LanipToName(target) # 根据当前IP 输出主机名\n        elif cmd == '-hostname':\n            LanName2IP(target)  # 根据当前主机名输出ip\n```\n\n\n\n","tags":["网络"],"categories":["socket"]},{"title":"模拟网络嗅探器","url":"/dp.github.io/2017/02/06/mynew1/","content":"\nstruct: 按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;按照指定格式将字节流转换为Python指定的数据类型;\n\n\n\nICMP协议：ICMP协议用于IP主机、路由器之间传递控制消息，这里的控制消息可以包括很多种:数据报错误信息、网络状况信息、主机状况信息等;虽然这些控制消息虽然并不传输用户数据，但对于用户数据报的有效递交起着重要作用，从TCP//IP的分层结构看ICMP属于网络层,它配合着IP数据报的提交,提高IP数据报递交的可靠性。ICMP是封装在IP数据报中进行发送的，从这点看来 ICMP 协议又有点像一个传输层协议，其实不然，因为ICMP报文的目的不是目的主机上的某个应用程序，它不为应用程序提供传输服务，ICMP报文的目的是目的主机上的网络层处理软件。简单的来说,ICMP协议就像奔波于网络中的一名医生,它能及时检测并汇报网络中可能存在的问题，为解决网络错误或拥塞提供了最有效的手段。\n\n\n\n```python\nimport socket\nimport os\nimport struct\nfrom ctypes import *\n\n\nhost = '192.168.249.1'\n\nclass IP(Structure):\n    _fields = [\n        (\"ihl\", c_ubyte, 4),\n        (\"version\", c_ubyte, 4),\n        (\"tos\", c_ubyte),\n        (\"len\", c_ushort),\n        (\"id\", c_ushort),\n        (\"offset\", c_ushort),\n        (\"ttl\", c_ubyte),\n        (\"protocol_num\", c_ubyte),\n        (\"sum\", c_ushort),\n        (\"src\", c_ulong),\n        (\"dst\", c_ulong)\n        ]\n    def __new__(self, socket_buffer=None):\n        return self.from_buffer_copy(socket_buffer)\n\n    def __init__(self,socket_buffer=None):\n        self.protocol_map = {1:'ICMP', 6:'TCP', 17:'UDP'}\n        self.src_address = socket.inet_ntoa(struct.pack(\"<L\",self.src))\n        self.dst_address = socket.inet_ntoa(struct.pack(\"<L\",self.dst))\n\n        try:\n            self.protocol = self.protocol_map[self.protocol_num]\n\n        except:\n            self.protocol = str(self.protocol_num)\n\nif os.name == \"nt\":\n    socket_protocol = socket.IPPROTO_IP\n\nelse:\n    socket_protocol = socket.IPPROTO_ICMP\n\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)\n\nsniffer.bind((host,0))\n\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL,1)\n\nif os.name == 'nt':\n    sniffer.ioctl(socket.SIO_RCVALL,socket.RCVALL_ON)\n\ntry:\n    while True:\n        raw_buffer = sniffer.recvfrom(65565)[0]\n        ip_header = IP(raw_buffer[0:20])\n        print(\"Protocol:%s %s -> %s\"%(ip_header.protocol,ip_header.src_address,ip_header.dst_address))\nexcept:\n    if os.name == \"nt\":\n        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\n    print('出现错误！')\n```\n\n\n\n\n\n\n\n","tags":["网络"],"categories":["socket"]},{"title":"linux root用户密码破解","url":"/dp.github.io/2016/04/17/linux-root/","content":"\n##### Root 用户破解流程\n\n> 1. e ; 进入 VMware 页面 按 e 进入编辑模式。\n> 2. rd.break ; 在quiet后加入 rd.break。\n> 3. ctrl + x; 按 ctrl + x 进入 swtch_root 模式。\n> 4. mout -o remount,rw /sysroot ; 重新挂载分区。\n> 5. chroot /sysroot ; 切换根分区。\n> 6. passwd root ; 修改root密码，必须是8位以上复杂密码。\n> 7. touch /.autorelabel ; selinux 在重启后更新label。\n> 8. exit ； 退出。\n> 9. reboot ； 重启","tags":["Linux"],"categories":["Linux"]},{"title":"汽车之家图片爬取","url":"/dp.github.io/2016/03/27/qctp/","content":"\n##### 新建爬虫类爬取网站图片，并保存到文件夹\n\n```python\n# 汽车之家图片爬取\nimport time\nimport os\nimport urllib.request\nfrom bs4 import BeautifulSoup\nfrom multiprocessing  import Pool\n\n\n# 获取汽车图片方法类\nclass ReTbmm(object):\n\n    def Retbmm(self):\n        # 爬虫开始时间\n        start = time.time()\n        # 用于返回当前工作目录\n        self.cdir = os.getcwd()\n        # 爬起网址 https://car.autohome.com.cn/pic/series/5349.html#pvareaid=2042194\n        # 车身外观\n        url1 = 'https://car.autohome.com.cn/pic/series/5349-1.html#pvareaid=2042220'\n\n        # 中控方向盘\n        url2 = 'https://car.autohome.com.cn/pic/series/5349-10.html#pvareaid=2042220'\n\n        # 车厢座椅\n        url3 = 'https://car.autohome.com.cn/pic/series/5349-3.html#pvareaid=2042220'\n\n        # 其他细节\n        url4 = 'https://car.autohome.com.cn/pic/series/5349-12.html#pvareaid=2042220'\n\n        self.getImg('车身外观',url1)\n        self.getImg('中控方向盘',url2)\n        self.getImg('车厢座椅',url3)\n        self.getImg('其他细节',url4)\n        end = time.time()\n        print('run time',str(end - start))\n\n    # 下载图片方法\n    def getImg(self,name,url):\n        user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' \\\n                     '(KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36'\n        headers = {'User-Agent':user_agent}\n        # 访问连接\n        request = urllib.request.Request(url,headers=headers)\n        # 获取数据\n        response = urllib.request.urlopen(request)\n        # 解析数据\n        bsobj = BeautifulSoup(response,'html.parser')\n        # 获取所有img标签\n        t1 = bsobj.find_all('img')\n\n        path = self.cdir + '\\\\mrsoft\\\\' + str(name)\n\n        if not os.path.exists(path):\n            os.mkdir(path)\n        n = 0\n        for img in t1:\n            n = n + 1\n            link = img.get('src')\n\n            if link :\n                # 图片连接\n                s = 'https:' + str(link)\n\n                i = link[link.rfind('.'):]\n                try:\n                    req = urllib.request.Request(s)\n                    res = urllib.request.urlopen(req)\n                    imgData = res.read()\n                    pathfile = path + r'\\\\' +str(n) + i\n\n                    with open(pathfile,'wb')as f:\n                        f.write(imgData)\n                        f.close()\n                except:\n                    print(str(name)+'thread write false'+ s)\n\nif __name__ == '__main__':\n    r = ReTbmm()\n    pool = Pool(4)\n    for i in range(1,10):\n        pool.apply_async(func=r.Retbmm)\n    pool.close()\n    pool.join()\n\n\n\n```\n\n","tags":["爬虫"],"categories":["python"]},{"title":"面向对象","url":"/dp.github.io/2016/03/22/oo/","content":"\n##### 封装、继承、多态\n\n> 1. 封装\n>    1. 对数据处理时，可以快速定位到需要的方法，修改时更方便。\n>    2. 全局变量是只能由1份的，多个函数需要多个备份时，需要利用其他变量来进行存储；通过封装会将用来存储数据的这个变量 变成对象中的一个'全局'变量，只要对象不一样那么这个变量就可以再有一份。\n>    3. 代码划分更清晰。\n> 2. 继承\n>    1. 能提升代码的重用率，开发一个类，可以在多个功能中直接使用。\n>    2. 继承能够有效的进行代码管理，当某个类有问题只要修改这个类就行，而其继承这个类的子类往往是不需要修改。\n> 3. 多态\n>    1. 不同子类对象调用相同的父类方法，产生不同执行结果。\n>    2. 多态可以增加代码的灵活度，以继承和重写父类方法为前提。\n>    3. 是调用方法的技巧，不会影响到类的内部设计。\n\n\n\n##### 多继承以及MRO顺序\n\n> 1. **super().____init____**相对于类名.____init____,在单继承上用法基本无差。\n> 2. 但在多继承上有区别，super方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次。\n> 3. 多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否者报错。\n> 4. 单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则报错。\n> 5. 多继承时，相对于使用类名.____init____方法，要把每个父类全部写一遍，而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的原因。\n>\n> 在python中，类变量在内部是作为字典处理的。如果一个变量的名字没有在当前类的字典中发现，将搜索父类直到被引用的变量名找到（如果这个引用的变量名即没有在自己所在的类有没有在父类中找到，会引发一个 AttributeError异常）。\n\n\n\n##### 实例方法、静态方法、类方法\n\n1. **类属性、实例属性**\n\n> 它们定义和使用中都有所区别，而最本质区别是内存中保存的位置不同。\n>\n> - 实例属性属于对象\n> - 类属性属于类\n> - 类属性在内存中只保存一份。\n> - 实例属性在每个对象中都要保存一份。\n\n2. **实例方法、静态方法、类方法**\n\n*方法包括：实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。* \n\n> - 实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self；\n> - 类方法：由类调用或对象调用；至少一个cls参数（默认是cls）；执行类方法时，自动将调用该方法的类赋值给cls；应用场景：当一个方法中只涉及到静态属性的时候可以使用类方法(类方法用来修改类属性) \n> - 静态方法：由类调用或对象调用；无默认参数；应用场景：一般用于和类对象以及实例对象无关的代码。 \n\n3. **对比**\n   - 相同点：对于所有方法而言，均属于类，所以在内存中也只保留一份。\n   - 不同点：方法调用不同，调用方法传参也不同。\n\n\n\n##### python property属性\n\n> - Python的property属性的功能是：property属性内部进行一系列的逻辑计算，最终将计算结果返回。 \n> - 定义property属性共有两种方式，分别是【装饰器】和【类属性】，而【装饰器】方式针对经典类和新式类又有所不同。 \n> -  通过使用property属性，能够简化获取数据的流程 ","tags":["python"],"categories":["python"]}]