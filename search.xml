<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程与进程</title>
      <link href="/dp.github.io/2020/03/17/xjc/"/>
      <url>/dp.github.io/2020/03/17/xjc/</url>
      
        <content type="html"><![CDATA[<p>线程与进程的区别：<br>    1、进程是系统进行资源分配和调度的一个单位，线程是进程的一个实体，是cpu调度和分配的基本单位。</p><p>​    2、进程之间是相互独立的，多进程中，同一个变量，各自有一个备份存在于每个进程中，但互不影响；而<br>          同一个进程的多个线程是内存共享的，所有变量都由所有线程共享。</p><p>​    3、由于进程间是相互独立的，因此一个进程的崩溃不会影响到其他进程；而线程是包含在进程之内的，<br>          线程的崩溃就会引发进程的崩溃，继而导致同一个进程内的其他线程也崩溃。多线程非全局变量是<br>         否要加锁；在多线程开发中，全局变量是多个线程都共享的数据，为了防止数据混乱，通常使用互斥锁。<br>         而局部变量等是各自线程的，是非共享的，所以不需要使用互斥锁。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络爬虫分类详解</title>
      <link href="/dp.github.io/2020/03/17/pac1/"/>
      <url>/dp.github.io/2020/03/17/pac1/</url>
      
        <content type="html"><![CDATA[<p>1.通用网络爬虫；<br>        .1 通用网络爬虫又叫做全网爬虫，通用网络爬虫的爬取范围和数量巨大，正由于其爬取的数据是海量数据，<br>        所以对于爬取速度和存储空间要求较高。通用网络在爬行页面的顺序要求上相对较低，同时由于待刷新的<br>        页面太多，通常采用并行工作方式，所以需要较长时间才可以刷新一次页面，所以存在一定的缺陷，这种<br>        网络爬虫主要应用于大型搜索引擎中，又非常高应用价值。通用网络爬虫主要由初始URL集合、URL队列、<br>        页面爬取模块、页面分析模块、页面数据库、链接过滤模块等构成。</p><p>2.聚焦网络爬虫；<br>        .2 聚焦网络爬虫也叫做主题网络爬虫，是指按照预定好的主题，有选择地进行相关网页爬取。他和通用<br>        网络爬虫相比，不会将目标资源定位在整个互联网当中，而是将爬取目标网页定位在相关的页面中。这<br>        样极大地节省了硬件和网络资源，保存的页面也由于数量少而更快了，聚焦网络爬虫主要应用在对特定<br>        信息爬取，为某一特定人群提供服务。<br>3.增量式网络爬虫；<br>        .3 增量式网络爬虫，所谓增量式，对应着增量式更新。增量式更新指的是在更新的时候只更新改变的地方，<br>        而未改变的地方则不更新，所以增量式网络爬虫，在爬取网页的时候，只会在需要的时候爬区新产生或跟<br>        新的页面，对于没有更新的页面，则不会爬取。这样可有效减少数据下载量，减少时间和空间上的消费，<br>        但是再爬行算法上需要增加一些难度。<br>4.深层网络爬虫；<br>        .4  1web页面按存在方式可以分为表层网页和深层网页，表层网页指的是不需要提交表单，使用静态的超链    接，<br>        就可以直接访问静态页面。深层网页指的是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后面<br>        的，需要用户提交一些关键词才能获得的web页面。深层页面需要访问的信息数量是表层页面信息数量的几<br>        百倍，所以深层页面是主要的爬取对象。</p><p>网络爬虫的基本原理：<br>    1.网络爬虫的基本工作流程；<br>    （1）获取初始的URL，该URL地址使用户自己制定的初始爬取的网页。<br>    （2）爬取对应的URL地址的网页时，获取新的URL地址。<br>    （3）将新的URL地址放入URL队列中。<br>    （4）从URL对列中读取新的URL，然后根据新的URL爬取网页，同时从新的网页中获取新的URL地址，重复上             述爬虫过程。<br>    （5）设置停止条件，如果没有设置停止条件爬虫会一直爬取直到无法获取新的URL。</p><p>python网络请求：<br>    在python中实现HTTP网络请求常见三种方式：urllib、urlliib3、requests。<br>    1. urllib 模块<br>        .1 urllib是python自带模块，该模块提供了一个urlopen()方法，通过该方法指定URL发送网络请求来获取数据。<br>        urllib提供了多个子模块具体如下：<br>        模块名称         |                 描述<br>        urllib.request  |   该模块定义了打开URL（主要是HTTP）的方法和类。例如身份验证、重定向、cookie等。<br>        urllib.error    |   该模块主要包含异常类，基本的异常类是URLError。<br>        urllib.parse    |   该模块定义的功能分为两大类：URL解析和URL引用。<br>        urllib.robotparser | 该模块用于解析robots.txt 文件。</p><pre><code>网络请求示例:</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例一</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="comment"># 打开指定需要爬取的网页</span></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">html = response.read()  <span class="comment"># 读取网页代码</span></span><br><span class="line">print(html)             <span class="comment"># 打印读取内容</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例二</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="comment"># 将数据使用urlencode编码处理后，在使用encoding设置为utf-8编码</span></span><br><span class="line">data = bytes(urllib.parse.urlencode(&#123;<span class="string">'word'</span>:<span class="string">'hello'</span>&#125;),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 打开指定需要爬取的网页</span></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://httpbin.org/post'</span>,data=data)</span><br><span class="line">html = response.read()  <span class="comment"># 读取网页代码</span></span><br><span class="line">print(html)             <span class="comment"># 打印读取内容</span></span><br></pre></td></tr></table></figure><p>上面示例中，示例一是通过get请求方式获取网页内容，示例二是通过post请求方式获取网页内容。</p><p>2.urllib3 模块<br>        .2 urllib3是一个功能强大、条理清晰、用于HTTP客户端的python库，许多python的原生系统已经开始使用urllib3.<br>        urllib3 提供了很多python标准库里所没有的重要特性：<br>        （1）线程安全。<br>        （2）连接池。<br>        （3）客户端SSL/TTS验证。<br>        （4）使用多部分编码上传文件。<br>        （5）Helpers 用于重试请求并处理HTTP重定向。<br>        （6）支持gzip和deflate编码。<br>        （7） 支持HTTP和SOCKS代理。<br>        （8）100% 的测试覆盖率。</p><p>​    网络请求示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建 poolManager对象，用于处理于线程池的连接以及线程安全的所有细节。</span></span><br><span class="line">http = urllib3.poolManager()</span><br><span class="line"><span class="comment"># 对需要爬取的网页发送请求  get/post</span></span><br><span class="line">response = http.request(<span class="string">'GET'</span>,<span class="string">'http://httpbin.org/'</span>)</span><br><span class="line"><span class="comment"># response = http.request('POST','http://httpbin.org/',fields=&#123;'word':'hello'&#125;)</span></span><br><span class="line">print(response.data)    <span class="comment"># 打印读取内容</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>requests 模块</p><pre><code>requests 是第三方模块，该模块在实现HTTP请求时要比urllib 模块简单化很多，操作人性化。requests 功能特性如下:(1)Keep-Alive &amp; 连接池            (2)Unicode 响应体(3)国际化域名和URL                 (4)HTTP(S)代理支持(5)带持久Cookie 的会话             (6)文件分块上传(7)浏览器式的SSL认证               (8)流下载(9)自动内容解码                    (10)连接超时(11)基本/摘要式的身份验证            (12)分块请求(13)key/value Cookie              (14)支持.netrc(15)自动解压</code></pre><p> 以GET请求为例，打印多种请求信息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">print(response.status_code)   <span class="comment"># 打印状态码</span></span><br><span class="line">print(response.url)   <span class="comment"># 打印请求url</span></span><br><span class="line">print(response.headers)   <span class="comment"># 打印头部信息</span></span><br><span class="line">print(response.cookies)   <span class="comment"># 打印cookie信息</span></span><br><span class="line">print(respomse.text)   <span class="comment"># 以文本形式打印网页源码</span></span><br><span class="line">print(response.content)   <span class="comment"># 以字节流形式打印网页源码</span></span><br><span class="line"></span><br><span class="line">以post请求，发送http网络请求:</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'word'</span>:<span class="string">'hello'</span>&#125;</span><br><span class="line">response = requests.post(<span class="string">'https://www.baidu.com'</span>,data=data)</span><br><span class="line">print(response.content)</span><br></pre></td></tr></table></figure></li></ol><p>requests 模块不及提供了以上两种，还有多种方式:<br>    (1) requests.put()<br>    (2) requests.delete()<br>    (3) requests.head()<br>    (4) requests.options()</p><p>​    requests 模块提供了三种常见的网络异常类，示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests.exceptions 模块中三个异常类</span></span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ReadTimeout, HTTPError, RequestException</span><br><span class="line">ReadTimeout（超时异常） HTTPError（HTTP异常） RequestException（请求异常）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 python 解析 ppt 文档</title>
      <link href="/dp.github.io/2020/03/15/jppt/"/>
      <url>/dp.github.io/2020/03/15/jppt/</url>
      
        <content type="html"><![CDATA[<p><strong>模块的重载</strong>：考虑到性能的原因，每个模块只被导入一次,放入字典sys.module中，如果你改变了模块的内容，你必须重启程序，python不支持重新加载或卸载之前导入的模块，可以使用importlib 模块(python默认编码是ASCII编码，当程序出现非ASCII码时，python处理常常出现[UnicodeDecodeError:]错误，此时需要自己设置编码，通常为utf-8)。</p><p><strong>具体代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys,importlib</span><br><span class="line">importlib.reload(sys)</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time1=time.time()</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfparser <span class="keyword">import</span> PDFParser,PDFDocument</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> PDFResourceManager, PDFPageInterpreter</span><br><span class="line"><span class="keyword">from</span> pdfminer.converter <span class="keyword">import</span> PDFPageAggregator</span><br><span class="line"><span class="keyword">from</span> pdfminer.layout <span class="keyword">import</span> LTTextBoxHorizontal,LAParams</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> PDFTextExtractionNotAllowed</span><br><span class="line">result=[]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPdf2TxtManager</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="string">'''''</span></span><br><span class="line"><span class="string">      Constructor</span></span><br><span class="line"><span class="string">      '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">changePdfToText</span><span class="params">(self, filePath)</span>:</span></span><br><span class="line">      file = open(path, <span class="string">'rb'</span>) <span class="comment"># 以二进制读模式打开</span></span><br><span class="line">      <span class="comment">#用文件对象来创建一个pdf文档分析器</span></span><br><span class="line">      praser = PDFParser(file)</span><br><span class="line">      <span class="comment"># 创建一个PDF文档</span></span><br><span class="line">      doc = PDFDocument()</span><br><span class="line">      <span class="comment"># 连接分析器 与文档对象</span></span><br><span class="line">      praser.set_document(doc)</span><br><span class="line">      doc.set_parser(praser)</span><br><span class="line">      <span class="comment"># 提供初始化密码</span></span><br><span class="line">      <span class="comment"># 如果没有密码 就创建一个空的字符串</span></span><br><span class="line">      doc.initialize()</span><br><span class="line">      <span class="comment"># 检测文档是否提供txt转换，不提供就忽略</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> doc.is_extractable:</span><br><span class="line">        <span class="keyword">raise</span> PDFTextExtractionNotAllowed</span><br><span class="line">      <span class="comment"># 创建PDf 资源管理器 来管理共享资源</span></span><br><span class="line">      rsrcmgr = PDFResourceManager()</span><br><span class="line">      <span class="comment"># 创建一个PDF设备对象</span></span><br><span class="line">      laparams = LAParams()</span><br><span class="line">      device = PDFPageAggregator(rsrcmgr, laparams=laparams)</span><br><span class="line">      <span class="comment"># 创建一个PDF解释器对象</span></span><br><span class="line">      interpreter = PDFPageInterpreter(rsrcmgr, device)</span><br><span class="line">      pdfStr = <span class="string">''</span></span><br><span class="line">      <span class="comment"># 循环遍历列表，每次处理一个page的内容</span></span><br><span class="line">      <span class="keyword">for</span> page <span class="keyword">in</span> doc.get_pages(): <span class="comment"># doc.get_pages() 获取page列表</span></span><br><span class="line">        interpreter.process_page(page)</span><br><span class="line">        <span class="comment"># 接受该页面的LTPage对象</span></span><br><span class="line">        layout = device.get_result()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> layout:</span><br><span class="line">          <span class="keyword">if</span> hasattr(x, <span class="string">"get_text"</span>):</span><br><span class="line">            <span class="comment"># print x.get_text()</span></span><br><span class="line">            result.append(x.get_text())</span><br><span class="line">            fileNames = os.path.splitext(filePath)</span><br><span class="line">            results = x.get_text()</span><br><span class="line">            <span class="comment"># print(results)</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="string">'''''</span></span><br><span class="line"><span class="string">   解析pdf 文本，保存到txt文件中</span></span><br><span class="line"><span class="string">  '''</span></span><br><span class="line">  path = <span class="string">u'D:\text\book\text.pdf'</span></span><br><span class="line">  pdf2TxtManager = CPdf2TxtManager()</span><br><span class="line">  pdf2TxtManager.changePdfToText(path)</span><br><span class="line">  time2 = time.time()</span><br><span class="line">  print(<span class="string">u'ok,解析pdf结束!'</span>)</span><br><span class="line">  print(<span class="string">u'总共耗时：'</span> + str(time2 - time1) + <span class="string">'s'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫描并输出局域网占用的 IP 地址</title>
      <link href="/dp.github.io/2020/03/15/mynew2/"/>
      <url>/dp.github.io/2020/03/15/mynew2/</url>
      
        <content type="html"><![CDATA[<p><strong>sys.argv[] 指令:</strong> 是一个程序外部来获取参数的，0是指代码本身的路径。可以通过外部来获取多个参数，类似列表。所以使用[]来获取。</p><p><strong>argparse</strong> :<br>是命令行解析模块；sys.argv[]是通过外部传的参数，无法通过编辑器直接运行，而是通过dos命令行里操作；两者可以结合使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys,  socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">list_of_name = []</span><br><span class="line">list_of_ip = []</span><br><span class="line">thread_pool = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showInfo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"""</span></span><br><span class="line"><span class="string">        命令格式：LAN_ip_hostname -all startip</span></span><br><span class="line"><span class="string">                LAN_ip_hostname -ip ipaddr</span></span><br><span class="line"><span class="string">                LAN_ip_hostname -hostname hostname</span></span><br><span class="line"><span class="string">        说明：   -all 扫描局域网中所有IP对应的 hostname，需要起始IP，如192.168.0.1</span></span><br><span class="line"><span class="string">                -ip 获取指定ip的hostname</span></span><br><span class="line"><span class="string">                -hostname 根据主机名，得到ip地址</span></span><br><span class="line"><span class="string">    """</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LanAll</span><span class="params">(startip)</span>:</span></span><br><span class="line">    index = startip.rfind(<span class="string">'.'</span>) <span class="comment"># 找出最右边 . 的索引</span></span><br><span class="line">    ipfirstpart = startip[<span class="number">0</span>:index + <span class="number">1</span>] <span class="comment"># ip 地址中前三位，如 192.168.0.1</span></span><br><span class="line">    intstart = int(startip[index + <span class="number">1</span>])  <span class="comment"># ip 地址最后一位，转为int</span></span><br><span class="line">    f = range(intstart,<span class="number">255</span>)</span><br><span class="line">    <span class="keyword">global</span> g_mutex</span><br><span class="line">    g_mutex = threading.Lock()  <span class="comment"># 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">for</span> iplastpart <span class="keyword">in</span> f:</span><br><span class="line">        targetip = ipfirstpart + str(iplastpart) <span class="comment"># 拼接ip</span></span><br><span class="line">        <span class="comment"># 创建线程对象，存为 thread 线程要执行的函数由 target 指定，args 指定参数，</span></span><br><span class="line">        <span class="comment"># 可以是元组~。线程号从 1 开始</span></span><br><span class="line">        thread = threading.Thread(target=Lanlp2Name,args=(targetip,))</span><br><span class="line">        thread_pool.append(thread)</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="comment"># 阻塞主线程 collect all threads</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> f:</span><br><span class="line">        threading.Thread.join(thread_pool[pos - intstart])</span><br><span class="line">    <span class="comment">#输出结果</span></span><br><span class="line">    hosts = range(<span class="number">0</span>,len(list_of_name))</span><br><span class="line">    <span class="keyword">for</span> host <span class="keyword">in</span> hosts:</span><br><span class="line">        print(list_of_ip[host],<span class="string">'======&gt;'</span>,list_of_name[host])</span><br><span class="line">    print(<span class="string">'Find'</span>,len(list_of_name),<span class="string">'hosts.Done!'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lanlp2Name</span><span class="params">(ip)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (name, aliaslist,addresslist) = socket.gethostbyaddr(ip)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">global</span> g_mutex <span class="comment"># 再次声明</span></span><br><span class="line">    g_mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">    list_of_name.append(name)</span><br><span class="line">    list_of_ip.append(ip)</span><br><span class="line">    g_mutex.release()  <span class="comment"># 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LanipToName</span><span class="params">(ip)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (name, aliaslist,addresslist) = socket.gethostbyaddr(ip)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(<span class="string">'%s ======&gt;%s'</span>%(addresslist,name))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LanName2IP</span><span class="params">(name)</span>:</span></span><br><span class="line">    targetip = socket.gethostbyname(name)</span><br><span class="line">    print(name,<span class="string">'=====&gt;'</span>,targetip)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'参数错误'</span>)</span><br><span class="line">        showInfo()</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    cmds = [<span class="string">'-all'</span>,<span class="string">'-ip'</span>,<span class="string">'-hostname'</span>]</span><br><span class="line">    cmd = sys.argv[<span class="number">1</span>] <span class="comment"># 命令格式</span></span><br><span class="line">    target = sys.argv[<span class="number">2</span>] <span class="comment"># ip地址</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> == cmds.count(cmd):</span><br><span class="line">        print(<span class="string">'参数错误啊'</span>)</span><br><span class="line">        showInfo()</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'开始工作请等待...'</span>)</span><br><span class="line">        <span class="keyword">if</span> cmd == <span class="string">'-all'</span>:</span><br><span class="line">            LanAll(target) <span class="comment"># 输出所有的 主机 与 ip 名</span></span><br><span class="line">        <span class="keyword">elif</span> cmd  == <span class="string">'-ip'</span>:</span><br><span class="line">            LanipToName(target) <span class="comment"># 根据当前IP 输出主机名</span></span><br><span class="line">        <span class="keyword">elif</span> cmd == <span class="string">'-hostname'</span>:</span><br><span class="line">            LanName2IP(target)  <span class="comment"># 根据当前主机名输出ip</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> socket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟网络嗅探器</title>
      <link href="/dp.github.io/2020/02/06/mynew1/"/>
      <url>/dp.github.io/2020/02/06/mynew1/</url>
      
        <content type="html"><![CDATA[<p>struct: 按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;按照指定格式将字节流转换为Python指定的数据类型;</p><p>ICMP协议：ICMP协议用于IP主机、路由器之间传递控制消息，这里的控制消息可以包括很多种:数据报错误信息、网络状况信息、主机状况信息等;虽然这些控制消息虽然并不传输用户数据，但对于用户数据报的有效递交起着重要作用，从TCP//IP的分层结构看ICMP属于网络层,它配合着IP数据报的提交,提高IP数据报递交的可靠性。ICMP是封装在IP数据报中进行发送的，从这点看来 ICMP 协议又有点像一个传输层协议，其实不然，因为ICMP报文的目的不是目的主机上的某个应用程序，它不为应用程序提供传输服务，ICMP报文的目的是目的主机上的网络层处理软件。简单的来说,ICMP协议就像奔波于网络中的一名医生,它能及时检测并汇报网络中可能存在的问题，为解决网络错误或拥塞提供了最有效的手段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">host = <span class="string">'192.168.249.1'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    _fields = [</span><br><span class="line">        (<span class="string">"ihl"</span>, c_ubyte, <span class="number">4</span>),</span><br><span class="line">        (<span class="string">"version"</span>, c_ubyte, <span class="number">4</span>),</span><br><span class="line">        (<span class="string">"tos"</span>, c_ubyte),</span><br><span class="line">        (<span class="string">"len"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"id"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"offset"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"ttl"</span>, c_ubyte),</span><br><span class="line">        (<span class="string">"protocol_num"</span>, c_ubyte),</span><br><span class="line">        (<span class="string">"sum"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"src"</span>, c_ulong),</span><br><span class="line">        (<span class="string">"dst"</span>, c_ulong)</span><br><span class="line">        ]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(self, socket_buffer=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.from_buffer_copy(socket_buffer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,socket_buffer=None)</span>:</span></span><br><span class="line">        self.protocol_map = &#123;<span class="number">1</span>:<span class="string">'ICMP'</span>, <span class="number">6</span>:<span class="string">'TCP'</span>, <span class="number">17</span>:<span class="string">'UDP'</span>&#125;</span><br><span class="line">        self.src_address = socket.inet_ntoa(struct.pack(<span class="string">"&lt;L"</span>,self.src))</span><br><span class="line">        self.dst_address = socket.inet_ntoa(struct.pack(<span class="string">"&lt;L"</span>,self.dst))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.protocol = self.protocol_map[self.protocol_num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.protocol = str(self.protocol_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.name == <span class="string">"nt"</span>:</span><br><span class="line">    socket_protocol = socket.IPPROTO_IP</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    socket_protocol = socket.IPPROTO_ICMP</span><br><span class="line"></span><br><span class="line">sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)</span><br><span class="line"></span><br><span class="line">sniffer.bind((host,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">sniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.name == <span class="string">'nt'</span>:</span><br><span class="line">    sniffer.ioctl(socket.SIO_RCVALL,socket.RCVALL_ON)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        raw_buffer = sniffer.recvfrom(<span class="number">65565</span>)[<span class="number">0</span>]</span><br><span class="line">        ip_header = IP(raw_buffer[<span class="number">0</span>:<span class="number">20</span>])</span><br><span class="line">        print(<span class="string">"Protocol:%s %s -&gt; %s"</span>%(ip_header.protocol,ip_header.src_address,ip_header.dst_address))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">"nt"</span>:</span><br><span class="line">        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)</span><br><span class="line">    print(<span class="string">'出现错误！'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> socket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的 GUI 框架</title>
      <link href="/dp.github.io/2019/12/18/my-first-one/"/>
      <url>/dp.github.io/2019/12/18/my-first-one/</url>
      
        <content type="html"><![CDATA[<p>1.什么是 GUI<br>  GUI是 Graphilcal User Interface（图形用户界面）的缩写。在GUI中，并不只是输入文本和返回文本，用户可以看待窗口、按钮、<br>  文本框等图形，而且可以用鼠标单击，还可以通过键盘输入。GUI 是与程序交互的一种不同的方式。GUI 的程序由三个基本要素：输入、处理和输出。</p><p>2.常用的GUI框架<br>  工具包     |                 描述<br>  wxpython  |        wxpython是python语言的一套优秀的GUI图形库，允许python程序员方便创建完整的、功能健全的GUI用户界面。<br>  Kivy      |        Kivy是一个开源工具包，可以跨平台使用，主要关注创新型用户界面开发，如多点触摸应用程序。<br>  Flexx     |        Flexx是纯python工具包，用来创建图形化界面应用程序。使用web技术进行页面渲染。<br>  PyQt      |        PyQt是Qt库的python版本，支持跨平台。<br>  Tkinter   |        Tkinter（也叫做Tk接口）是标准的python接口，Tk是一个轻量级的跨平台图形用户界面开发工具。<br>  pywin32   |        Windows pywin32允许用户像VC一样的形式来使用python开发win32 应用。<br>  PyGTK     |        PyGTK让用户用python轻松创建具有图形用户界面的程序。<br>  pyui4win  |        pyui4win是一个开源的采用自绘技术的界面库。</p>]]></content>
      
      
      <categories>
          
          <category> GUI(图形用户界面) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
